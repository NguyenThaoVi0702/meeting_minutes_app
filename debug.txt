Of course. This is the final and most crucial step: verifying that everything works together as expected. A dedicated testing client is the perfect way to do this.

Here is a complete solution to test your API from a separate Docker container, including the Python script, the Dockerfile, and instructions on how to set it up and run it.

1. File Structure for Your Testing Environment

Create a new folder completely separate from your main project directory. For example:

code
Code
download
content_copy
expand_less

/my_projects/
├── my_api_project/       <-- Your main application code is here
│   ├── docker-compose.yml
│   ├── app/
│   └── ...
└── api_tester/           <-- Create this new folder
    ├── speaker_samples/  <-- Place your speaker's .wav files here
    │   ├── sample1.wav
    │   └── sample2.wav
    ├── meeting_chunks/   <-- Place your meeting chunk files here
    │   ├── meeting_xyz_0.wav
    │   ├── meeting_xyz_1.wav
    │   └── meeting_xyz_2.wav
    ├── Dockerfile.tester
    ├── requirements.txt
    └── test_api.py
2. The Testing Files

Place the following files inside your new api_tester directory.

requirements.txt

This file lists the Python libraries needed for the test script.

code
Txt
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
requests
websocket-client
Dockerfile.tester

This Dockerfile creates the isolated environment for your test script.

code
Dockerfile
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
# Dockerfile.tester

FROM python:3.9-slim

WORKDIR /tester

# Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy the test script and the data folders into the container
COPY test_api.py .
COPY ./speaker_samples ./speaker_samples
COPY ./meeting_chunks ./meeting_chunks

# The command to run the test script when the container starts
CMD ["python", "test_api.py"]
test_api.py

This is the main testing script. Read the comments in the CONFIG section at the top carefully and modify the values to match your setup.

code
Python
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
import os
import time
import json
import uuid
import threading
from typing import List, Dict
from pathlib import Path

import requests
import websocket

# ===================================================================
#   CONFIGURATION - MODIFY THESE VALUES
# ===================================================================

# The base URL of your running API.
# If your tester container is on the same Docker network, you can use the service name.
# If you run the script locally or from a different network, use 'http://localhost:8000'
API_BASE_URL = os.getenv("API_URL", "http://host.docker.internal:8000") # 'host.docker.internal' works on Docker Desktop

# Details for the new speaker to enroll
SPEAKER_USER_AD = "testuser001"
SPEAKER_DISPLAY_NAME = "Test User"
SPEAKER_SAMPLES_DIR = Path("./speaker_samples")

# Details for the meeting to upload
# The script will find all files in this folder and sort them by the number at the end.
MEETING_CHUNKS_DIR = Path("./meeting_chunks")
MEETING_FILENAME = "test_meeting.wav"
MEETING_BBH_NAME = "Quarterly Review"
MEETING_TYPE = "Board Meeting"
MEETING_HOST = "CEO"
MEETING_LANGUAGE = "vi" # Change to 'en' if needed

# This is the user who "owns" the meeting
USERNAME = "api_tester"

# ===================================================================
#   API Call Helper
# ===================================================================

def api_call(method, endpoint, params=None, data=None, files=None, expect_json=True):
    """A helper function to make API calls and handle responses."""
    url = f"{API_BASE_URL}{endpoint}"
    print(f"-> {method.upper()} {url}")
    try:
        response = requests.request(method, url, params=params, data=data, files=files, timeout=60)
        response.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)
        if expect_json:
            return response.json()
        return response.content
    except requests.exceptions.RequestException as e:
        print(f"!! API Call Failed: {e}")
        if hasattr(e.response, 'text'):
            print(f"!! Response Body: {e.response.text}")
        raise

# ===================================================================
#   WebSocket Client
# ===================================================================

class WebSocketListener(threading.Thread):
    def __init__(self, request_id):
        super().__init__()
        self.ws_url = f"{API_BASE_URL.replace('http', 'ws')}/api/v1/meeting/ws/{request_id}"
        self.ws = None
        self.daemon = True # Allows main thread to exit even if this one is running
        self._stop_event = threading.Event()

    def run(self):
        print(f"--> WebSocket connecting to {self.ws_url}")
        self.ws = websocket.WebSocketApp(
            self.ws_url,
            on_message=lambda ws, msg: self.on_message(ws, msg),
            on_error=lambda ws, err: self.on_error(ws, err),
            on_close=lambda ws, code, msg: print("--> WebSocket closed.")
        )
        self.ws.run_forever()

    def on_message(self, ws, message):
        print("\n\n---\nWebSocket UPDATE RECEIVED:\n---")
        data = json.loads(message)
        # Pretty print the JSON response
        print(json.dumps(data, indent=2, ensure_ascii=False))
        if data.get("status") in ["completed", "failed", "cancelled"]:
            print("--- (Final status received, closing WebSocket) ---\n")
            self.stop()
        print("\n---")


    def on_error(self, ws, error):
        print(f"!! WebSocket Error: {error}")

    def stop(self):
        if self.ws:
            self.ws.close()

# ===================================================================
#   Main Test Execution
# ===================================================================

def main():
    """Run the full API test suite."""
    print("--- Starting API Test Suite ---")
    
    # Generate a unique ID for this meeting session
    request_id = f"test-session-{uuid.uuid4().hex[:8]}"
    print(f"Generated Meeting Request ID: {request_id}")

    try:
        # 1. Health Check
        print("\n--- 1. Testing Health Check ---")
        health = api_call("GET", "/health")
        print(f"API Status: {health.get('status')}")

        # 2. Speaker Enrollment
        print(f"\n--- 2. Testing Speaker Enrollment for '{SPEAKER_USER_AD}' ---")
        speaker_files = [("files", (f.name, open(f, "rb"), "audio/wav")) for f in SPEAKER_SAMPLES_DIR.glob("*.wav")]
        if not speaker_files:
            raise FileNotFoundError(f"No speaker sample .wav files found in {SPEAKER_SAMPLES_DIR}")
        metadata = json.dumps({"display_name": SPEAKER_DISPLAY_NAME, "user_ad": SPEAKER_USER_AD})
        enroll_response = api_call("POST", "/api/v1/speaker/", data={"metadata": metadata}, files=speaker_files)
        print(f"Enrollment Response: {enroll_response}")

        # 3. Speaker Management
        print(f"\n--- 3. Testing Speaker Management ---")
        search_res = api_call("GET", "/api/v1/speaker/search", params={"query": SPEAKER_USER_AD})
        print(f"Search found {len(search_res['data'])} result(s).")
        profile_res = api_call("GET", f"/api/v1/speaker/{SPEAKER_USER_AD}")
        print(f"Profile Details for '{profile_res['user_ad']}' retrieved.")

        # 4. Meeting Workflow
        print(f"\n--- 4. Testing Meeting Workflow for Request ID '{request_id}' ---")
        
        # Start WebSocket listener in the background
        ws_listener = WebSocketListener(request_id)
        ws_listener.start()
        time.sleep(2) # Give it a moment to connect

        # Start the meeting
        start_data = {
            "requestId": request_id, "language": MEETING_LANGUAGE, "filename": MEETING_FILENAME,
            "bbhName": MEETING_BBH_NAME, "Type": MEETING_TYPE, "Host": MEETING_HOST, "username": USERNAME
        }
        api_call("POST", "/api/v1/meeting/start-bbh", data=start_data)
        
        # Upload chunks
        chunk_files = sorted(
            MEETING_CHUNKS_DIR.glob("*.wav"),
            key=lambda f: int(f.stem.split('_')[-1])
        )
        if not chunk_files:
             raise FileNotFoundError(f"No meeting chunk .wav files found in {MEETING_CHUNKS_DIR}")
        
        for i, chunk_path in enumerate(chunk_files):
            is_last = (i == len(chunk_files) - 1)
            chunk_data = {"requestId": request_id, "isLastChunk": str(is_last)}
            chunk_files_payload = {"FileData": (chunk_path.name, open(chunk_path, "rb"), "audio/wav")}
            api_call("POST", "/api/v1/meeting/upload-file-chunk", data=chunk_data, files=chunk_files_payload)
            time.sleep(0.5) # Simulate a short delay between chunks

        # 5. Wait for Processing & Trigger Diarization
        print("\n--- 5. Waiting for Transcription to Complete (watch WebSocket updates) ---")
        time.sleep(45) # Adjust this sleep time based on your audio length and model speed

        print("\n--- Triggering Diarization ---")
        api_call("POST", f"/api/v1/meeting/{request_id}/diarize", params={"username": USERNAME})

        print("\n--- Waiting for Diarization to Complete (watch WebSocket updates) ---")
        time.sleep(45) # Adjust this sleep time as well

        # 6. Analysis and Downloads
        print(f"\n--- 6. Testing Analysis and Downloads for '{request_id}' ---")
        status_res = api_call("GET", f"/api/v1/meeting/{request_id}/status", params={"username": USERNAME})
        print("Final status retrieved. Plain transcript has", len(status_res['data']['plain_transcript']), "segments.")
        print("Diarized transcript has", len(status_res['data']['diarized_transcript']), "segments.")

        # Generate all summaries
        for summary_type in ["topic", "speaker", "action_items", "decision_log"]:
            print(f"\n--- Generating '{summary_type}' summary ---")
            summary_res = api_call("POST", f"/api/v1/meeting/{request_id}/summary", data=json.dumps({"summary_type": summary_type}), params={"username": USERNAME})
            print(f"Summary content received (length: {len(summary_res['summary_content'])}).")

        # Chat
        print("\n--- Testing Chat ---")
        chat_payload = {"requestId": request_id, "username": USERNAME, "message": "What were the main decisions?"}
        chat_res = api_call("POST", "/api/v1/meeting/chat", data=json.dumps(chat_payload))
        print(f"Chatbot response: {chat_res['response']}")
        
        # Download Audio
        print("\n--- Testing Audio Download ---")
        audio_content = api_call("GET", f"/api/v1/meeting/{request_id}/download/audio", params={"username": USERNAME}, expect_json=False)
        with open("downloaded_meeting.wav", "wb") as f:
            f.write(audio_content)
        print("Audio file 'downloaded_meeting.wav' saved.")

        # Download Documents
        for doc_type in ["bbh_hdqt", "nghi_quyet"]:
            print(f"\n--- Testing Document Download for '{doc_type}' ---")
            doc_content = api_call("GET", f"/api/v1/meeting/{request_id}/download/document", params={"username": USERNAME, "template_type": doc_type}, expect_json=False)
            filename = f"downloaded_{doc_type}.docx"
            with open(filename, "wb") as f:
                f.write(doc_content)
            print(f"Document '{filename}' saved.")

    finally:
        # 7. Cleanup
        print(f"\n--- 7. Cleaning Up: Deleting Speaker '{SPEAKER_USER_AD}' ---")
        try:
            delete_res = api_call("DELETE", f"/api/v1/speaker/{SPEAKER_USER_AD}")
            print(f"Cleanup Response: {delete_res}")
        except Exception as e:
            print(f"Could not delete speaker (may have failed earlier): {e}")

        if 'ws_listener' in locals() and ws_listener.is_alive():
            ws_listener.stop()
        
        print("\n--- Test Suite Finished ---")


if __name__ == "__main__":
    main()
3. How to Run the Test

Start Your Main Application: Make sure your main API is running.

code
Bash
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
cd /path/to/my_api_project
docker-compose up --build -d

Find Your Docker Network Name: The tester container needs to join the same network as your API to communicate. Run this command to list your Docker networks:

code
Bash
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
docker network ls

Look for a network named something like my_api_project_default. Copy this name.

Build and Run the Tester Container:
Navigate to your api_tester directory. Then, run the following command, replacing <your_network_name> with the name you just copied.

code
Bash
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
# In the api_tester directory
docker build -t api-tester -f Dockerfile.tester .

docker run --rm --network=<your_network_name> api-tester

Example:

code
Bash
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
docker run --rm --network=my_api_project_default api-tester

Alternative (if host.docker.internal works for you):
If you are using Docker Desktop (Windows/Mac), you can often connect to services running on your local machine using the special DNS name host.docker.internal. In this case, you can simplify the run command (and leave the API_BASE_URL in the script as is):

code
Bash
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
docker run --rm api-tester

You will now see the output of the test_api.py script in your terminal as it goes through each step, making calls to your API, printing responses, and showing real-time updates from the WebSocket.
