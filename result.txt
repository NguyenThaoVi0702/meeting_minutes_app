import os
import re
import requests
import uuid
from datetime import datetime
import time

# --- Configuration ---
API_BASE_URL = "http://10.43.128.107:8086"
USER_ID = "batch_processor_user"
MEETING_FOLDER_NAME = "Meeting1_TO_11092025_0930_1105" # Change for other meetings
OUTPUT_FOLDER_PATH = "/app"

# --- NEW: Configuration for retrying ---
# How many times to try fetching the transcript before giving up
TRANSCRIPT_RETRY_ATTEMPTS = 10 
# How many seconds to wait between each attempt
TRANSCRIPT_RETRY_DELAY_SECONDS = 15 

def get_chunk_id(filename):
    """Extracts the numerical chunk ID from the filename."""
    match = re.search(r'_(\d+)\.wav$', filename)
    if match:
        return int(match.group(1))
    return -1

def process_meeting_folder():
    """
    Finds chunks, sends them for processing, and downloads the final summary.
    Includes retry logic for waiting on server-side processing.
    """
    session_id = f"meeting_{datetime.now().strftime('%Y%m%d%H%M%S')}_{uuid.uuid4().hex[:8]}"
    print(f"--- Starting processing for new session: {session_id} ---")

    meeting_folder_path = os.path.join(OUTPUT_FOLDER_PATH, MEETING_FOLDER_NAME)
    if not os.path.isdir(meeting_folder_path):
        print(f"Error: Folder not found at '{meeting_folder_path}'")
        return

    all_files = [f for f in os.listdir(meeting_folder_path) if f.endswith(".wav")]
    all_files.sort(key=get_chunk_id)

    if not all_files:
        print(f"No .wav files found in '{meeting_folder_path}'")
        return

    print(f"Found {len(all_files)} chunks. Sorted and ready for transcription.")

    print("\n--- Step 1: Transcribing all audio chunks ---")
    transcription_url = f"{API_BASE_URL}/transcriptions"
    successful_transcriptions = 0
    for i, filename in enumerate(all_files):
        filepath = os.path.join(meeting_folder_path, filename)
        print(f"  ({i+1}/{len(all_files)}) Sending {filename} for transcription...")
        
        try:
            with open(filepath, 'rb') as audio_file:
                files = {'file': (filename, audio_file, 'audio/wav')}
                data = {'session_id': session_id, 'user_id': USER_ID}
                response = requests.post(transcription_url, files=files, data=data, timeout=120)
                
                if response.status_code == 200:
                    print(f"    -> Success. Server has accepted the chunk.")
                    successful_transcriptions += 1
                else:
                    print(f"    -> Error! Status: {response.status_code}, Response: {response.text}")
        except requests.exceptions.RequestException as e:
            print(f"    -> Network Error processing {filename}: {e}")
        time.sleep(0.5)

    if successful_transcriptions == 0:
        print("\nNo chunks were successfully sent for transcription. Aborting.")
        return

    print(f"\n--- Step 2: Retrieving full transcript (with retries) ---")
    get_all_segment_url = f"{API_BASE_URL}/get-all-segment"
    full_text = ""
    
    # THIS IS THE NEW RETRY LOGIC
    for attempt in range(TRANSCRIPT_RETRY_ATTEMPTS):
        print(f"  Attempt {attempt + 1}/{TRANSCRIPT_RETRY_ATTEMPTS}: Querying for full transcript...")
        try:
            data = {'session_id': session_id, 'user_id': USER_ID}
            response = requests.post(get_all_segment_url, data=data, timeout=60)
            
            if response.status_code == 200:
                response_data = response.json()
                full_text = response_data.get("full_text", "")
                if full_text and full_text.strip(): # Check if text is not empty or just whitespace
                    print("  -> Success! Full transcript has been retrieved.")
                    break # Exit the retry loop
                else:
                    print(f"  -> Transcript not ready yet. Waiting {TRANSCRIPT_RETRY_DELAY_SECONDS} seconds...")
                    time.sleep(TRANSCRIPT_RETRY_DELAY_SECONDS)
            else:
                print(f"  -> API returned an error! Status: {response.status_code}. Retrying...")
                time.sleep(TRANSCRIPT_RETRY_DELAY_SECONDS)
        except requests.exceptions.RequestException as e:
            print(f"  -> Network Error during retrieval: {e}. Retrying...")
            time.sleep(TRANSCRIPT_RETRY_DELAY_SECONDS)

    if not full_text or not full_text.strip():
        print("\nFailed to retrieve the full transcript after all attempts. Aborting process.")
        return

    # --- Steps 3 and 4 remain the same, as they depend on the successful completion of Step 2 ---

    print("\n--- Step 3: Sending transcript for summarization ---")
    summary_url = f"{API_BASE_URL}/summary"
    try:
        files = {'file': ('full_transcript.txt', full_text.encode('utf-8'), 'text/plain')}
        data = {'session_id': session_id, 'user_id': USER_ID}
        response = requests.post(summary_url, files=files, data=data, timeout=180)
        
        if response.status_code == 200:
            print("  -> Successfully submitted for summarization.")
        else:
            print(f"  -> Error submitting for summary! Status: {response.status_code}, Response: {response.text}")
            return
    except requests.exceptions.RequestException as e:
        print(f"  -> Network Error during summarization: {e}")
        return

    print("\n--- Step 4: Downloading the final .docx report ---")
    download_url = f"{API_BASE_URL}/download-word"
    output_docx_filename = f"BienBanHop_{MEETING_FOLDER_NAME}.docx"
    output_docx_path = os.path.join(OUTPUT_FOLDER_PATH, output_docx_filename)
    try:
        data = {'session_id': session_id, 'user_id': USER_ID}
        response = requests.post(download_url, data=data, timeout=60, stream=True)
        
        if response.status_code == 200:
            with open(output_docx_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            print(f"  -> Success! Document saved to: {output_docx_path}")
        else:
            print(f"  -> Error downloading document! Status: {response.status_code}, Response: {response.text}")
    except requests.exceptions.RequestException as e:
        print(f"  -> Network Error downloading document: {e}")

    print("\n--- Processing complete. ---")


if __name__ == "__main__":
    process_meeting_folder()
