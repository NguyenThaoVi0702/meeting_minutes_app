import os
import shutil
from pydub import AudioSegment
from datetime import datetime, timedelta

def sort_audio_chunks_dynamically(input_folder_path, output_folder_path, meeting_defs):
    """
    Analyzes audio chunks and copies them into subfolders based on a dynamic list
    of meeting time slot definitions. This version correctly calculates the chunk's
    start time based on its modification time and duration.
    """
    
    # 1. Prepare meeting definitions (This part is correct and remains the same)
    print("--- Preparing meeting definitions and output folders ---")
    for meeting in meeting_defs:
        try:
            folder_path = os.path.join(output_folder_path, meeting["name"])
            os.makedirs(folder_path, exist_ok=True)
            meeting["folder_path"] = folder_path
            start_h, start_m = map(int, meeting["start_time"].split(':'))
            end_h, end_m = map(int, meeting["end_time"].split(':'))
            meeting["start_td"] = timedelta(hours=start_h, minutes=start_m)
            meeting["end_td"] = timedelta(hours=end_h, minutes=end_m)
            print(f"  - Prepared output folder: {folder_path} for time slot {meeting['start_time']} to {meeting['end_time']}")
        except Exception as e:
            print(f"Error processing meeting definition '{meeting.get('name', 'N/A')}': {e}. Skipping this definition.")
            meeting["is_valid"] = False
        else:
            meeting["is_valid"] = True
    
    print("\n--- Scanning and collecting audio chunk data ---")
    chunk_data = []
    for filename in os.listdir(input_folder_path):
        if filename.endswith(".wav") and f"TO {TARGET_DATE_STR}" in filename:
            filepath = os.path.join(input_folder_path, filename)
            try:
                mtime_timestamp = os.path.getmtime(filepath)
                mtime_datetime = datetime.fromtimestamp(mtime_timestamp)
                duration_ms = len(AudioSegment.from_wav(filepath))
                chunk_data.append((filepath, filename, mtime_datetime, duration_ms))
                print(f"  - Found {filename}: mtime (end time)={mtime_datetime.strftime('%H:%M:%S')}, duration={duration_ms/1000:.1f}s")
            except Exception as e:
                print(f"Error processing file {filename}: {e}. Skipping.")

    if not chunk_data:
        print(f"\nNo audio files found matching 'TO {TARGET_DATE_STR}' in '{input_folder_path}'")
        return

    chunk_data.sort(key=lambda x: x[2])
    print(f"\nSorted {len(chunk_data)} audio chunks by modification time.")

    first_chunk_mtime = chunk_data[0][2]
    recording_day_start = datetime(first_chunk_mtime.year, first_chunk_mtime.month, first_chunk_mtime.day)

    print("\n--- Assigning and copying chunks to meeting folders ---")
    for filepath, filename, mtime_datetime, duration_ms in chunk_data:
        # --- THE FIX IS HERE ---
        # The 'mtime' is the END of the recording. Calculate the START.
        duration_td = timedelta(milliseconds=duration_ms)
        chunk_start_datetime = mtime_datetime - duration_td
        
        # Now calculate the relative start and end times for the chunk
        chunk_relative_start_td = chunk_start_datetime - recording_day_start
        chunk_relative_end_td = mtime_datetime - recording_day_start # The end is simply the original mtime
        
        # --- END OF FIX ---

        # Loop through prepared meeting definitions to see where this chunk fits
        for meeting in meeting_defs:
            if not meeting.get("is_valid", False):
                continue
                
            # The overlap check logic is correct, but now it uses the right start/end times
            if (chunk_relative_start_td < meeting["end_td"] and
                chunk_relative_end_td > meeting["start_td"]):
                
                dest_path = os.path.join(meeting["folder_path"], filename)
                print(f"  -> Copying {filename} (recorded {chunk_start_datetime.strftime('%H:%M:%S')}-{mtime_datetime.strftime('%H:%M:%S')}) to {meeting['name']} folder.")
                shutil.copy2(filepath, dest_path)

    print("\n--- Processing complete. ---")
