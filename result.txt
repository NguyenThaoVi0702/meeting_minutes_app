import os
import re
import requests
import uuid
from datetime import datetime
import time

# --- Configuration ---
API_BASE_URL = "http://10.43.128.107:8086"
USER_ID = "batch_processor_user"
MEETING_FOLDER_NAME = "Meeting1_TO_11092025_0930_1105" # Change for other meetings
OUTPUT_FOLDER_PATH = "/app" # The script's working directory inside the container

def get_chunk_id(filename):
    """Extracts the numerical chunk ID from the filename."""
    match = re.search(r'_(\d+)\.wav$', filename)
    if match:
        return int(match.group(1))
    return -1

def process_meeting_folder():
    """
    Checks for a pre-existing transcript file. If found, uses it.
    Otherwise, transcribes audio chunks, then summarizes and downloads the final document.
    """
    session_id = f"meeting_{datetime.now().strftime('%Y%m%d%H%M%S')}_{uuid.uuid4().hex[:8]}"
    print(f"--- Starting processing for session: {session_id} ---")
    
    full_text = ""
    
    # Define the expected name of the pre-transcribed text file
    transcript_filename = f"{MEETING_FOLDER_NAME}.txt"
    transcript_filepath = os.path.join(OUTPUT_FOLDER_PATH, transcript_filename)

    # --- NEW LOGIC: Check if the transcript file already exists ---
    if os.path.exists(transcript_filepath):
        print(f"\n--- Found existing transcript file: '{transcript_filename}' ---")
        print("--- Skipping audio transcription step and reading from file. ---")
        try:
            with open(transcript_filepath, 'r', encoding='utf-8') as f:
                full_text = f.read()
            print("Successfully read content from the transcript file.")
        except Exception as e:
            print(f"Error reading transcript file: {e}. Aborting.")
            return
    else:
        # --- ORIGINAL LOGIC: If file doesn't exist, transcribe audio chunks ---
        print(f"\n--- Transcript file not found. Proceeding with audio transcription. ---")
        
        meeting_folder_path = os.path.join(OUTPUT_FOLDER_PATH, MEETING_FOLDER_NAME)
        if not os.path.isdir(meeting_folder_path):
            print(f"Error: Audio folder not found at '{meeting_folder_path}'")
            return

        all_files = [f for f in os.listdir(meeting_folder_path) if f.endswith(".wav")]
        all_files.sort(key=get_chunk_id)

        if not all_files:
            print(f"No .wav files found in '{meeting_folder_path}'")
            return

        print(f"Found {len(all_files)} chunks. Sorted and ready for processing.")

        print("\n--- Step 1: Transcribing chunks and collecting text ---")
        full_transcript_parts = []
        transcription_url = f"{API_BASE_URL}/transcriptions"
        
        for i, filename in enumerate(all_files):
            filepath = os.path.join(meeting_folder_path, filename)
            print(f"  ({i+1}/{len(all_files)}) Processing {filename}...")
            try:
                with open(filepath, 'rb') as audio_file:
                    files = {'file': (filename, audio_file, 'audio/wav')}
                    data = {'session_id': session_id, 'user_id': USER_ID}
                    response = requests.post(transcription_url, files=files, data=data, timeout=120)
                    
                    if response.status_code == 200:
                        response_data = response.json()
                        chunk_text = response_data.get("text", "")
                        if chunk_text:
                            print(f"    -> Success. Received transcript chunk.")
                            full_transcript_parts.append(chunk_text.strip())
                        else:
                            print(f"    -> Warning: Server returned success but text was empty.")
                    else:
                        print(f"    -> Error! Status: {response.status_code}, Response: {response.text}")
            except requests.exceptions.RequestException as e:
                print(f"    -> Network Error processing {filename}: {e}")
        
        full_text = " ".join(full_transcript_parts)
    
    # --- The rest of the script continues from here, with full_text populated either way ---
    if not full_text.strip():
        print("\nTranscript is empty. Aborting process.")
        return
        
    print(f"\nSuccessfully prepared full transcript for summarization.")

    # --- Step 2: Send the full transcript for summarization ---
    print("\n--- Step 2: Sending transcript for summarization ---")
    # (The rest of the code is identical to the previous version)
    summary_url = f"{API_BASE_URL}/summary"
    try:
        files = {'file': ('full_transcript.txt', full_text.encode('utf-8'), 'text/plain')}
        data = {'session_id': session_id, 'user_id': USER_ID}
        response = requests.post(summary_url, files=files, data=data, timeout=180)
        
        if response.status_code == 200:
            print("  -> Successfully submitted for summarization.")
        else:
            print(f"  -> Error submitting for summary! Status: {response.status_code}, Response: {response.text}")
            return
    except requests.exceptions.RequestException as e:
        print(f"  -> Network Error during summarization: {e}")
        return

    # --- Step 3: Download the final Word document ---
    print("\n--- Step 3: Downloading the final .docx report ---")
    download_url = f"{API_BASE_URL}/download-word"
    output_docx_filename = f"BienBanHop_{MEETING_FOLDER_NAME}.docx"
    output_docx_path = os.path.join(OUTPUT_FOLDER_PATH, output_docx_filename)
    try:
        print("  Waiting 10 seconds for summary to be generated on the server...")
        time.sleep(10)

        data = {'session_id': session_id, 'user_id': USER_ID}
        response = requests.post(download_url, data=data, timeout=60, stream=True)
        
        if response.status_code == 200:
            with open(output_docx_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            print(f"  -> Success! Document saved to: {output_docx_path}")
        else:
            print(f"  -> Error downloading document! Status: {response.status_code}, Response: {response.text}")
    except requests.exceptions.RequestException as e:
        print(f"  -> Network Error downloading document: {e}")

    print("\n--- Processing complete. ---")


if __name__ == "__main__":
    process_meeting_folder()
