import os
import shutil
import re
from pub import AudioSegment
from datetime import datetime, timedelta, time

# --- ⚠️ IMPORTANT CONFIGURATION - PLEASE SET THESE VALUES ---

# 1. SET THE REAL-WORLD START TIME of the very first audio chunk (e.g., the file ending in "_1.wav").
#    Use 24-hour format "HH:MM". This is the most critical setting.
RECORDING_SESSION_START_TIME = "09:00" 

# 2. SET THE STRING to find in your audio filenames.
FILENAME_CONTAINS_STRING = "TO 11092025"

# 3. DEFINE YOUR MEETINGS.
MEETING_DEFINITIONS = [
    {
        "name": "Meeting_1100_1800",
        "start_time": "11:00",
        "end_time": "18:00"
    }
]
# --- END OF CONFIGURATION ---

def extract_chunk_number(filename):
    """Extracts the numerical chunk number from a filename like '..._123.wav'."""
    match = re.search(r'_(\d+)\.wav$', filename)
    if match:
        return int(match.group(1))
    return -1 # Return a value that sorts non-matching files last

def sort_audio_chunks_by_timeline(input_folder_path, output_folder_path, meeting_defs):
    """
    Builds a reliable timeline based on chunk numbers and a known start time,
    then copies files to their corresponding meeting folders.
    """
    
    # 1. Prepare meeting definitions
    print("--- Preparing meeting definitions and output folders ---")
    for meeting in meeting_defs:
        try:
            folder_path = os.path.join(output_folder_path, meeting["name"])
            os.makedirs(folder_path, exist_ok=True)
            meeting["folder_path"] = folder_path
            
            start_h, start_m = map(int, meeting["start_time"].split(':'))
            end_h, end_m = map(int, meeting["end_time"].split(':'))
            meeting["start_t"] = time(hour=start_h, minute=start_m)
            meeting["end_t"] = time(hour=end_h, minute=end_m)
            
            print(f"  - Prepared output folder: {folder_path} for time slot {meeting['start_time']} to {meeting['end_time']}")
            meeting["is_valid"] = True
        except Exception as e:
            print(f"Error processing meeting definition '{meeting.get('name', 'N/A')}': {e}. Skipping.")
            meeting["is_valid"] = False
            
    # 2. Collect chunk data
    print("\n--- Scanning and collecting audio chunk data ---")
    chunk_data = []
    for filename in os.listdir(input_folder_path):
        if filename.endswith(".wav") and FILENAME_CONTAINS_STRING in filename:
            filepath = os.path.join(input_folder_path, filename)
            chunk_number = extract_chunk_number(filename)
            if chunk_number == -1:
                print(f"  - Warning: Could not extract chunk number from {filename}. Skipping.")
                continue
            try:
                duration_ms = len(AudioSegment.from_wav(filepath))
                chunk_data.append({
                    "filepath": filepath,
                    "filename": filename,
                    "chunk_num": chunk_number,
                    "duration": timedelta(milliseconds=duration_ms)
                })
                print(f"  - Found {filename} (Chunk {chunk_number}), duration={duration_ms/1000:.1f}s")
            except Exception as e:
                print(f"Error processing file {filename}: {e}. Skipping.")

    if not chunk_data:
        print(f"\nNo valid audio files found containing '{FILENAME_CONTAINS_STRING}' in '{input_folder_path}'")
        return

    # 3. Sort chunks by their CHUNK NUMBER to establish correct chronological order
    chunk_data.sort(key=lambda x: x["chunk_num"])
    print(f"\nSorted {len(chunk_data)} audio chunks by their chunk number.")

    # 4. Build the absolute timeline
    print("\n--- Building accurate timeline from chunk order ---")
    try:
        # Determine the date from the file's (unreliable) mtime - we only need the date part
        # Using the first file in the sorted list.
        mtime = os.path.getmtime(chunk_data[0]["filepath"])
        session_date = datetime.fromtimestamp(mtime).date()
        
        # Combine the session date with the configured start time
        start_h, start_m = map(int, RECORDING_SESSION_START_TIME.split(':'))
        current_time = datetime.combine(session_date, time(hour=start_h, minute=start_m))
        print(f"Timeline anchored. Session start time set to: {current_time.strftime('%Y-%m-%d %H:%M:%S')}")

    except Exception as e:
        print(f"Error setting up timeline start time: {e}. Please check RECORDING_SESSION_START_TIME.")
        return

    # Calculate start and end time for each chunk based on the timeline
    for chunk in chunk_data:
        chunk["start_time"] = current_time
        chunk["end_time"] = current_time + chunk["duration"]
        current_time = chunk["end_time"] # The next chunk starts when this one ends

    # 5. Assign and copy chunks based on the calculated timeline
    print("\n--- Assigning and copying chunks to meeting folders ---")
    for chunk in chunk_data:
        chunk_start_dt = chunk["start_time"]
        chunk_end_dt = chunk["end_time"]
        
        for meeting in meeting_defs:
            if not meeting.get("is_valid", False):
                continue
            
            # Create absolute datetime objects for the meeting's start and end on the same day
            meeting_start_dt = datetime.combine(session_date, meeting["start_t"])
            meeting_end_dt = datetime.combine(session_date, meeting["end_t"])
            
            # Check for overlap
            if (chunk_start_dt < meeting_end_dt and chunk_end_dt > meeting_start_dt):
                dest_path = os.path.join(meeting["folder_path"], chunk["filename"])
                print(f"  -> Copying {chunk['filename']} (calculated time {chunk_start_dt.strftime('%H:%M:%S')}-{chunk_end_dt.strftime('%H:%M:%S')}) to {meeting['name']} folder.")
                shutil.copy2(chunk["filepath"], dest_path)

    print("\n--- Processing complete. ---")


if __name__ == "__main__":
    input_data_container_path = "/app/input_data"
    output_results_container_path = "/app"

    sort_audio_chunks_by_timeline(
        input_data_container_path,
        output_results_container_path,
        MEETING_DEFINITIONS
    )
