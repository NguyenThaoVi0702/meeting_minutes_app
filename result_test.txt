import os
import shutil
import uuid
import logging
from pathlib import Path as FilePath
from typing import List

from fastapi import (
    APIRouter, HTTPException, status, Query, Form, File, UploadFile, Path
)
from pydantic import ValidationError
from qdrant_client import QdrantClient, models
from qdrant_client.http.models import UpdateStatus

from app.core.config import settings
from app.schemas.speaker import (
    AllSpeakersResponse, SpeakerProfileInfo, SpeakerSearchResponse,
    SpeakerSearchResult, GenericSuccessResponse, SpeakerMetadataUpdate,
    QdrantPointDetails, SpeakerProfileResponse
)
# --- FIX 1: REMOVE all direct imports from worker/processing layers ---
# from app.processing.enrollment import SpeakerEnrollment
# from app.worker.tasks import enroll_speaker_task
# --- FIX 2: ADD the celery_app import for decoupled task dispatching ---
from app.worker.celery_app import celery_app

logger = logging.getLogger(__name__)
router = APIRouter()

# This lightweight client is the ONLY way the API server should talk to the vector DB.
qdrant_client = QdrantClient(host=settings.QDRANT_HOST, port=settings.QDRANT_PORT, timeout=10)

# ===================================================================
#   Speaker Collection Endpoints (List & Search) - NOW LIGHTWEIGHT
# ===================================================================

@router.get("/", response_model=AllSpeakersResponse, summary="List all enrolled speaker profiles")
async def list_all_speakers():
    """Retrieves a list of all speaker profiles directly from the vector database."""
    try:
        all_points, _ = qdrant_client.scroll(
            collection_name=settings.QDRANT_COLLECTION_NAME,
            limit=10000,
            with_payload=True,
            with_vectors=False # Crucial for speed
        )
        profiles_data = [point.payload for point in all_points if point.payload]
        formatted_profiles = [SpeakerProfileInfo(**p) for p in profiles_data]
        return AllSpeakersResponse(data=formatted_profiles)
    except Exception as e:
        logger.error(f"Failed to list all speakers from Qdrant: {e}", exc_info=True)
        raise HTTPException(status_code=503, detail="Could not connect to the vector database.")

@router.get("/search", response_model=SpeakerSearchResponse, summary="Search for speaker profiles")
async def search_speaker_profiles(
    query: str = Query(..., min_length=1),
    limit: int = Query(10, ge=1, le=50)
):
    """Searches for speaker profiles using the vector DB's indexed metadata fields."""
    try:
        search_results = qdrant_client.search(
            collection_name=settings.QDRANT_COLLECTION_NAME,
            query_filter=models.Filter(must=[
                models.FieldCondition(key="search_terms", match=models.MatchValue(value=query.lower().strip()))
            ]),
            query_vector=[0.0] * 512, # Dummy vector for filtered search
            limit=limit,
            with_vectors=False
        )
        formatted_results = [SpeakerSearchResult(**hit.payload) for hit in search_results]
        return SpeakerSearchResponse(data=formatted_results)
    except Exception as e:
        logger.error(f"Failed during speaker search for query '{query}': {e}", exc_info=True)
        raise HTTPException(status_code=503, detail="An error occurred during search.")

# ===================================================================
#   Speaker Creation Endpoint - NOW FULLY ASYNC
# ===================================================================

@router.post("/", status_code=status.HTTP_202_ACCEPTED, response_model=GenericSuccessResponse)
async def enroll_new_speaker(
    metadata_json: str = Form(..., alias="metadata"),
    files: List[UploadFile] = File(...)
):
    """Accepts enrollment data, saves files, and queues the heavy processing to a worker."""
    try:
        metadata = SpeakerMetadataUpdate.model_validate_json(metadata_json)
        user_ad = metadata.user_ad.lower().strip()
    except (ValidationError, AttributeError) as e:
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=f"Invalid metadata: {e}")

    # Lightweight check for duplicates using the qdrant_client
    try:
        points, _ = qdrant_client.scroll(
            collection_name=settings.QDRANT_COLLECTION_NAME,
            scroll_filter=models.Filter(must=[models.FieldCondition(key="user_ad", match=models.MatchValue(value=user_ad))]),
            limit=1
        )
        if points:
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=f"Speaker '{user_ad}' already exists.")
    except Exception as e:
        raise HTTPException(status_code=503, detail=f"Could not verify speaker existence: {e}")

    # Save files to a permanent location for the worker
    enrollment_dir = FilePath(settings.ENROLLMENT_SAMPLES_PATH) / user_ad
    os.makedirs(enrollment_dir, exist_ok=True)
    
    saved_paths = []
    for file in files:
        if not file.filename: continue
        file_path = enrollment_dir / f"{uuid.uuid4()}_{file.filename}"
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
        saved_paths.append(str(file_path))

    if not saved_paths:
        raise HTTPException(status_code=400, detail="No valid audio files provided.")

    # Dispatch the background task using its registered name
    celery_app.send_task(
        "enroll_speaker_task",
        args=[user_ad, saved_paths, metadata.model_dump()]
    )
    return GenericSuccessResponse(message=f"Enrollment for '{user_ad}' has been accepted for processing.")

# ===================================================================
#   Individual Speaker Resource Endpoints
# ===================================================================

@router.get("/{user_ad}", response_model=SpeakerProfileResponse, summary="Get a specific speaker's profile")
async def get_speaker_profile_details(user_ad: str = Path(...)):
    """Retrieves detailed profile for a single speaker directly from the vector database."""
    try:
        points, _ = qdrant_client.scroll(
            collection_name=settings.QDRANT_COLLECTION_NAME,
            scroll_filter=models.Filter(must=[models.FieldCondition(key="user_ad", match=models.MatchValue(value=user_ad))]),
            limit=1, with_vectors=True
        )
        if not points:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Speaker '{user_ad}' not found.")
        
        profile_record = points[0]
        profile_details = QdrantPointDetails(
            qdrant_point_id=profile_record.id,
            payload=profile_record.payload,
            has_vector=bool(profile_record.vector)
        )
        return SpeakerProfileResponse(user_ad=user_ad, profile_details=profile_details)
    except Exception as e:
        raise HTTPException(status_code=503, detail=f"Could not retrieve speaker profile: {e}")

@router.put("/{user_ad}/metadata", status_code=status.HTTP_202_ACCEPTED, response_model=GenericSuccessResponse)
async def update_speaker_metadata(metadata: SpeakerMetadataUpdate, user_ad: str = Path(...)):
    """Accepts and queues a request to update a speaker's metadata."""
    celery_app.send_task(
        "update_metadata_task",
        args=[user_ad, metadata.model_dump(exclude_unset=True)]
    )
    return GenericSuccessResponse(message="Metadata update request has been accepted.")

@router.post("/{user_ad}/samples", status_code=status.HTTP_202_ACCEPTED, response_model=GenericSuccessResponse)
async def add_voice_samples_to_profile(user_ad: str = Path(...), files: List[UploadFile] = File(...)):
    """Accepts new voice samples and queues the profile update to a worker."""
    if not files or all(not f.filename for f in files):
        raise HTTPException(status_code=400, detail="No valid audio sample files provided.")

    samples_dir = FilePath(settings.ENROLLMENT_SAMPLES_PATH) / user_ad
    os.makedirs(samples_dir, exist_ok=True)
    
    saved_paths = []
    for file in files:
        if not file.filename: continue
        file_path = samples_dir / f"{uuid.uuid4()}_{file.filename}"
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
        saved_paths.append(str(file_path))

    if not saved_paths:
        raise HTTPException(status_code=400, detail="No valid audio files were processed.")

    celery_app.send_task("add_samples_task", args=[user_ad, saved_paths])
    return GenericSuccessResponse(message=f"Request to add {len(saved_paths)} new sample(s) has been accepted.")

@router.delete("/{user_ad}", response_model=GenericSuccessResponse, summary="Delete a speaker's profile")
async def delete_speaker_profile(user_ad: str = Path(...)):
    """Permanently deletes a speaker's profile from the vector database."""
    try:
        points, _ = qdrant_client.scroll(
            collection_name=settings.QDRANT_COLLECTION_NAME,
            scroll_filter=models.Filter(must=[models.FieldCondition(key="user_ad", match=models.MatchValue(value=user_ad))]),
            limit=1
        )
        if not points:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Speaker '{user_ad}' not found.")
        
        result = qdrant_client.delete(
            collection_name=settings.QDRANT_COLLECTION_NAME,
            points_selector=models.PointIdsList(points=[points[0].id]),
            wait=True
        )
        if result.status != UpdateStatus.COMPLETED:
             raise HTTPException(status_code=500, detail="Failed to delete profile from vector database.")
        
        return GenericSuccessResponse(message=f"Profile for '{user_ad}' was successfully deleted.")
    except Exception as e:
        raise HTTPException(status_code=503, detail=f"An error occurred while deleting the profile: {e}")
