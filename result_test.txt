# in app/api/routes/meeting.py

@router.websocket("/ws/{request_id}")
async def websocket_endpoint(websocket: WebSocket, request_id: str):
    """
    Establishes a WebSocket connection for receiving real-time updates
    about a meeting job's status.
    """
    # Accept the connection first, before doing any database work.
    # This is the most important change.
    await websocket.accept()
    
    # Now that the connection is accepted, add it to the manager.
    await websocket_manager.connect(websocket, request_id)
    
    try:
        # Use a proper session to get the initial status.
        with Session(engine) as session:
            job = session.exec(select(MeetingJob).where(MeetingJob.request_id == request_id)).first()
            if job:
                # Send the current status immediately upon connection
                initial_status = _format_job_status(job, session)
                await websocket.send_json(initial_status)
            else:
                # If the job isn't in the DB yet (very rare race condition), send a waiting message.
                await websocket.send_json({"status": "waiting", "request_id": request_id})
        
        # Keep the connection alive to receive broadcasted updates
        while True:
            # You can add a timeout here if you want to close inactive connections
            await websocket.receive_text()
            
    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected for request_id '{request_id}'.")
    except Exception as e:
        logger.error(f"Error in WebSocket endpoint for '{request_id}': {e}", exc_info=True)
    finally:
        # Ensure the client is always removed from the manager on exit
        websocket_manager.disconnect(websocket, request_id)
