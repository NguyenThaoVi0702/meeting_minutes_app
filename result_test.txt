Of course. This is the perfect way to validate the entire system. We will create a complete, isolated testing environment that simulates a real client, covering everything from Qdrant setup to the final API calls.

Here is the complete guide, broken down into four parts:

Part 1: How to Create the Qdrant Collection

Part 2: The Python Testing Environment Setup

Part 3: The Full Python Test Script

Part 4: How to Run Everything

Part 1: How to Create the Qdrant Collection

Before your application can store speaker embeddings, the collection must exist in Qdrant with the correct configuration. The easiest way to do this is with a small, separate Python script.

Create a file named create_qdrant_collection.py anywhere on your machine.

Install the client: pip install qdrant-client

Paste this code:

code
Python
download
content_copy
expand_less

# create_qdrant_collection.py
from qdrant_client import QdrantClient, models

# --- CONFIGURATION ---
QDRANT_HOST = "localhost"  # Use the host IP if Qdrant is on another machine
QDRANT_PORT = 7333         # The port you exposed in your qdrant container
COLLECTION_NAME = "meeting_speakers_v2" # MUST MATCH your app's .env file
VECTOR_SIZE = 512          # From the titanet-large model
DISTANCE_METRIC = models.Distance.COSINE

# --- SCRIPT ---
client = QdrantClient(host=QDRANT_HOST, port=QDRANT_PORT)

try:
    # Check if collection already exists
    client.get_collection(collection_name=COLLECTION_NAME)
    print(f"Collection '{COLLECTION_NAME}' already exists. No action taken.")

except Exception:
    print(f"Collection '{COLLECTION_NAME}' not found. Creating it now...")
    client.recreate_collection(
        collection_name=COLLECTION_NAME,
        vectors_config=models.VectorParams(size=VECTOR_SIZE, distance=DISTANCE_METRIC),
    )
    # This index is CRUCIAL for the speaker search endpoint to work
    client.create_payload_index(
        collection_name=COLLECTION_NAME,
        field_name="search_terms",
        field_schema=models.PayloadSchemaType.KEYWORD,
        wait=True
    )
    print(f"Successfully created collection '{COLLECTION_NAME}' and indexed 'search_terms'.")

Run the script from your terminal:

code
Bash
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
python create_qdrant_collection.py
```    This will connect to your running Qdrant container and create the collection. You only need to do this once.
Part 2: The Python Testing Environment Setup

We'll create a new folder for our test client, completely separate from your main application.

Create the Folder Structure:

code
Code
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
/my_api_test_client/
├── speaker_audio/
│   ├── speaker_one_name/
│   │   ├── sample1.wav
│   │   └── sample2.wav
│   └── speaker_two_name/
│       └── ...
├── meeting_to/
│   ├── MyFirstMeeting_0.wav
│   ├── MyFirstMeeting_1.wav
│   └── ...
├── speaker_metadata.csv
├── test_api.py             <-- We will create this
├── test_requirements.txt   <-- We will create this
├── Dockerfile              <-- We will create this
└── docker-compose.yml      <-- We will create this

Create test_requirements.txt:

code
Txt
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
requests
websocket-client

Create the Dockerfile for the test client:

code
Dockerfile
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
# Dockerfile
FROM python:3.9-slim

WORKDIR /test_client

# Copy requirements and install them
COPY test_requirements.txt .
RUN pip install --no-cache-dir -r test_requirements.txt

# Copy all test data and the script
COPY . .

# The command to run the test script
CMD ["python", "test_api.py"]

Create the docker-compose.yml to run the client:

code
Yaml
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
# docker-compose.yml
version: "3.8"

services:
  test-client:
    build: .
    container_name: meeting_api_test_client
    # This allows the container to talk to services on your host machine
    extra_hosts:
      - "host.docker.internal:host-gateway"
    # Mount the data folders so you can easily change them without rebuilding
    volumes:
      - ./speaker_audio:/test_client/speaker_audio
      - ./meeting_to:/test_client/meeting_to
      - ./speaker_metadata.csv:/test_client/speaker_metadata.csv
Part 3: The Full Python Test Script (test_api.py)

This script will perform a full end-to-end test of your API.

code
Python
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
# test_api.py
import requests
import os
import time
import csv
import glob
import json
import threading
import websocket

# --- CONFIGURATION ---
# Use this special DNS name to allow this container to talk to your main app
# containers, which are exposing a port (8000) on the host machine.
API_BASE_URL = "http://host.docker.internal:8000/api/v1"
SPEAKER_METADATA_PATH = "speaker_metadata.csv"
SPEAKER_AUDIO_DIR = "speaker_audio"
MEETING_AUDIO_DIR = "meeting_to"
TEST_USERNAME = "test_user_01"

# Global flag to signal when WebSocket can stop listening
WEBSOCKET_DONE = threading.Event()

# --- HELPER FUNCTIONS ---

def read_speaker_metadata():
    """Reads the CSV file into a dictionary keyed by the folder name."""
    metadata = {}
    with open(SPEAKER_METADATA_PATH, mode='r', encoding='utf-8') as infile:
        reader = csv.DictReader(infile)
        for row in reader:
            metadata[row['folder_name']] = row
    print(f"Loaded metadata for {len(metadata)} speakers.")
    return metadata

def group_meeting_chunks():
    """Groups meeting audio chunks by meeting name."""
    meetings = {}
    search_path = os.path.join(MEETING_AUDIO_DIR, '*.wav')
    for chunk_path in glob.glob(search_path):
        filename = os.path.basename(chunk_path)
        meeting_name = "_".join(filename.split('_')[:-1])
        if meeting_name not in meetings:
            meetings[meeting_name] = []
        meetings[meeting_name].append(chunk_path)
    
    # Sort chunks numerically by their ID
    for name, chunks in meetings.items():
        chunks.sort(key=lambda x: int(os.path.basename(x).split('_')[-1].split('.')[0]))

    print(f"Found {len(meetings)} meetings to process.")
    return meetings

def listen_on_websocket(request_id):
    """Connects to the WebSocket and prints status updates."""
    ws_url = f"{API_BASE_URL.replace('http', 'ws')}/meeting/ws/{request_id}"
    print(f"\n[WebSocket] Connecting to {ws_url}...")
    
    def on_message(ws, message):
        data = json.loads(message)
        status = data.get('status')
        print(f"\n[WebSocket] Received status update: {status}")
        if status in ['completed', 'failed', 'cancelled']:
            print(f"[WebSocket] Final status received. Closing connection.")
            WEBSOCKET_DONE.set() # Signal the main thread
            ws.close()

    def on_error(ws, error):
        print(f"[WebSocket] Error: {error}")
        WEBSOCKET_DONE.set()

    def on_close(ws, close_status_code, close_msg):
        print("[WebSocket] Connection closed.")

    def on_open(ws):
        print("[WebSocket] Connection opened.")

    ws = websocket.WebSocketApp(ws_url, on_open=on_open, on_message=on_message, on_error=on_error, on_close=on_close)
    ws.run_forever()

def run_full_test():
    """Main function to run the entire test suite."""
    metadata = read_speaker_metadata()
    meetings = group_meeting_chunks()
    
    # --- 1. Enroll Speakers ---
    print("\n--- STEP 1: ENROLLING SPEAKERS ---")
    speaker_folders = [d for d in os.listdir(SPEAKER_AUDIO_DIR) if os.path.isdir(os.path.join(SPEAKER_AUDIO_DIR, d))]
    for folder in speaker_folders:
        if folder in metadata:
            meta = metadata[folder]
            audio_files = glob.glob(os.path.join(SPEAKER_AUDIO_DIR, folder, '*.wav'))
            
            files_to_upload = [('files', (os.path.basename(f), open(f, 'rb'), 'audio/wav')) for f in audio_files]
            payload = {
                'metadata': json.dumps({
                    "display_name": meta['display_name'],
                    "user_ad": meta['user_ad']
                })
            }
            
            print(f"Enrolling speaker '{meta['user_ad']}' with {len(audio_files)} samples...")
            response = requests.post(f"{API_BASE_URL}/speaker/", data=payload, files=files_to_upload)
            print(f"  -> Status: {response.status_code}, Response: {response.json()}")
            time.sleep(1) # Be nice to the API

    # --- 2. Test Speaker CRUD ---
    print("\n--- STEP 2: TESTING SPEAKER CRUD ---")
    speakers_list = requests.get(f"{API_BASE_URL}/speaker/").json()['data']
    print(f"Found {len(speakers_list)} enrolled speakers.")
    
    if speakers_list:
        test_user_ad = speakers_list[0]['user_ad']
        print(f"Getting details for '{test_user_ad}'...")
        details = requests.get(f"{API_BASE_URL}/speaker/{test_user_ad}").json()
        print(f"  -> Details fetched successfully.")

        print(f"Updating metadata for '{test_user_ad}'...")
        update_payload = {"display_name": "A New Display Name"}
        response = requests.put(f"{API_BASE_URL}/speaker/{test_user_ad}/metadata", json=update_payload)
        print(f"  -> Status: {response.status_code}, Response: {response.json()}")

    if len(speakers_list) > 1:
        user_to_delete = speakers_list[1]['user_ad']
        print(f"Deleting speaker '{user_to_delete}'...")
        response = requests.delete(f"{API_BASE_URL}/speaker/{user_to_delete}")
        print(f"  -> Status: {response.status_code}, Response: {response.json()}")

    # --- 3. Process a Meeting ---
    print("\n--- STEP 3: PROCESSING A MEETING ---")
    if not meetings:
        print("No meetings found to process. Exiting.")
        return
        
    meeting_name, chunks = list(meetings.items())[0]
    request_id = f"test_{meeting_name}_{int(time.time())}"
    
    print(f"Starting meeting '{meeting_name}' with requestId '{request_id}'...")
    start_payload = {
        'requestId': request_id, 'username': TEST_USERNAME, 'language': 'vi',
        'filename': f"{meeting_name}.wav", 'bbhName': "Test BBH Name",
        'Type': "Test Type", 'Host': "Test Host"
    }
    response = requests.post(f"{API_BASE_URL}/meeting/start-bbh", data=start_payload)
    print(f"  -> Status: {response.status_code}, Response: {response.json()}")

    print("Uploading chunks...")
    for i, chunk_path in enumerate(chunks):
        is_last = (i == len(chunks) - 1)
        chunk_payload = {'requestId': request_id, 'isLastChunk': str(is_last)}
        files = {'FileData': (os.path.basename(chunk_path), open(chunk_path, 'rb'), 'audio/wav')}
        response = requests.post(f"{API_BASE_URL}/meeting/upload-file-chunk", data=chunk_payload, files=files)
        # print(f"  -> Uploaded {os.path.basename(chunk_path)}, Last: {is_last}, Status: {response.status_code}")
    print("All chunks uploaded.")

    # --- 4. Listen for Real-Time Updates & Trigger Next Steps ---
    print("\n--- STEP 4: WAITING FOR TRANSCRIPTION VIA WEBSOCKET ---")
    ws_thread = threading.Thread(target=listen_on_websocket, args=(request_id,))
    ws_thread.start()

    # Wait for the WebSocket to signal completion or timeout after 5 minutes
    WEBSOCKET_DONE.wait(timeout=300)
    
    if not WEBSOCKET_DONE.is_set():
        print("Test timed out waiting for WebSocket signal.")
        # Attempt to continue anyway
    
    print("\n--- STEP 5: TRIGGERING DIARIZATION ---")
    response = requests.post(f"{API_BASE_URL}/meeting/{request_id}/diarize?username={TEST_USERNAME}")
    print(f"  -> Status: {response.status_code}, Response: {response.json()}")
    
    # Reset event for the next wait
    WEBSOCKET_DONE.clear()
    print("Waiting for diarization to complete...")
    WEBSOCKET_DONE.wait(timeout=300)
    
    # --- 6. Test Analysis Endpoints ---
    print("\n--- STEP 6: TESTING ANALYSIS ENDPOINTS ---")
    # Test Topic Summary
    summary_payload = {"summary_type": "topic"}
    response = requests.post(f"{API_BASE_URL}/meeting/{request_id}/summary?username={TEST_USERNAME}", json=summary_payload)
    print(f"Topic Summary -> Status: {response.status_code}")

    # Test Speaker Summary
    summary_payload = {"summary_type": "speaker"}
    response = requests.post(f"{API_BASE_URL}/meeting/{request_id}/summary?username={TEST_USERNAME}", json=summary_payload)
    print(f"Speaker Summary -> Status: {response.status_code}")

    # Test Chat
    chat_payload = {"requestId": request_id, "username": TEST_USERNAME, "message": "What was the main conclusion?"}
    response = requests.post(f"{API_BASE_URL}/meeting/chat", json=chat_payload)
    print(f"Chat -> Status: {response.status_code}")

    # --- 7. Test Download Endpoints ---
    print("\n--- STEP 7: TESTING DOWNLOAD ENDPOINTS ---")
    # Test Audio Download
    response = requests.get(f"{API_BASE_URL}/meeting/{request_id}/download/audio?username={TEST_USERNAME}")
    print(f"Audio Download -> Status: {response.status_code}, Size: {len(response.content)} bytes")
    
    # Test Document Download
    params = {'username': TEST_USERNAME, 'template_type': 'bbh_hdqt'}
    response = requests.get(f"{API_BASE_URL}/meeting/{request_id}/download/document", params=params)
    print(f"Document Download -> Status: {response.status_code}, Size: {len(response.content)} bytes")

    ws_thread.join()
    print("\n--- TEST COMPLETE ---")

if __name__ == "__main__":
    run_full_test()
Part 4: How to Run Everything

Start Your Main Application: Make sure your main application (api, workers, postgres, qdrant, etc.) is running.

code
Bash
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
# In your main project folder
docker-compose up --build -d

Run the Qdrant Setup Script: If you haven't already, run the script from Part 1.

code
Bash
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
python create_qdrant_collection.py

Run the Test Client: Navigate to your new my_api_test_client folder and run its docker-compose command.

code
Bash
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
# In your my_api_test_client folder
docker-compose up --build

Your terminal will now show the output of test_api.py as it executes each step, from enrolling speakers to downloading the final documents. You can monitor the logs of your main application in a separate terminal to see it receiving and processing the requests.
