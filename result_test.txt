import json
import logging
import os
import shutil
from datetime import datetime
from pathlib import Path

from fastapi import (
    APIRouter, Depends, File, Form, HTTPException, Query, UploadFile, status,
    WebSocket, WebSocketDisconnect
)
from fastapi.responses import FileResponse, StreamingResponse
from pydub import AudioSegment, exceptions as pydub_exceptions
from sqlmodel import Session, select

from app.api.deps import (
    get_cancellable_job, get_db_session, get_job_ready_for_diarization,
    get_job_with_any_transcript, get_job_with_completed_diararization,
    get_or_create_user, get_owned_job_from_path
)
from app.core.config import settings
from app.db.base import engine
from app.db.models import ChatHistory, MeetingJob, Summary, Transcription, User
from app.schemas.meeting import (
    ChatRequest, ChatResponse, LanguageChangeRequest, MeetingInfoUpdateRequest,
    MeetingJobResponseWrapper, MeetingStatusResponse, PlainSegment,
    PlainTranscriptUpdateRequest, SummaryRequest, SummaryResponse
)
from app.services.ai_service import ai_service
from app.services.document_generator import generate_templated_document
from app.services.websocket_manager import websocket_manager
# --- FIX 1: REMOVE direct task imports, import the app itself ---
from app.worker.celery_app import celery_app

logger = logging.getLogger(__name__)
router = APIRouter()

# ===================================================================
#   Helper Functions & Core Workflow
# ===================================================================

def _format_job_status(job: MeetingJob, db: Session) -> dict:
    """Packages a MeetingJob object into the standard API response schema."""
    plain_transcript_data = None
    transcription_entry = db.exec(
        select(Transcription).where(
            Transcription.meeting_job_id == job.id,
            Transcription.language == job.language
        )
    ).first()

    if transcription_entry and transcription_entry.transcript_data:
        plain_transcript_data = [PlainSegment(**seg) for seg in transcription_entry.transcript_data]

    response = MeetingStatusResponse(
        request_id=job.request_id,
        status=job.status,
        bbh_name=job.bbh_name,
        meeting_type=job.meeting_type,
        meeting_host=job.meeting_host,
        language=job.language,
        plain_transcript=plain_transcript_data,
        diarized_transcript=job.diarized_transcript.transcript_data if job.diarized_transcript else None,
        error_message=job.error_message
    )
    return response.model_dump()


@router.post("/start-bbh", status_code=status.HTTP_201_CREATED, summary="Initialize a new meeting session")
async def start_bbh(
    session: Session = Depends(get_db_session),
    current_user: User = Depends(get_or_create_user),
    requestId: str = Form(...),
    language: str = Form("vi"),
    filename: str = Form(...),
    bbhName: str = Form(...),
    Type: str = Form(...),
    Host: str = Form(...),
):
    """Initializes a meeting job record in the database."""
    # ... (This function is already correct and requires no changes) ...


@router.post("/upload-file-chunk", status_code=status.HTTP_202_ACCEPTED, summary="Upload a single audio chunk")
async def upload_file_chunk(
    session: Session = Depends(get_db_session),
    requestId: str = Form(...),
    isLastChunk: bool = Form(...),
    FileData: UploadFile = File(...),
):
    """Saves an audio chunk and, if it's the last one, dispatches a task for assembly."""
    job = session.exec(select(MeetingJob).where(MeetingJob.request_id == requestId)).first()
    if not job:
        raise HTTPException(status_code=404, detail="Meeting job not found.")
    if job.status != "uploading":
        raise HTTPException(status_code=400, detail=f"Cannot upload chunks when job status is '{job.status}'.")

    if not job.upload_started_at:
        job.upload_started_at = datetime.utcnow()

    session_dir = Path(settings.SHARED_AUDIO_PATH) / requestId
    chunk_path = session_dir / FileData.filename
    with open(chunk_path, "wb") as buffer:
        shutil.copyfileobj(FileData.file, buffer)

    if isLastChunk:
        job.status = "assembling"
        job.upload_finished_at = datetime.utcnow()
        session.add(job)
        session.commit()
        
        logger.info(f"Last chunk received for '{requestId}'. Dispatching assembly task to Celery.")
        
        # --- FIX 2: Use send_task for decoupled dispatching ---
        celery_app.send_task("assemble_audio_task", args=[requestId, job.language])
        
        await websocket_manager.broadcast_to_job(requestId, {"status": "assembling"})
    else:
        session.add(job)
        session.commit()

    return {"status": 202, "message": f"Chunk '{FileData.filename}' accepted."}


@router.post("/{request_id}/diarize", status_code=status.HTTP_202_ACCEPTED, summary="Trigger speaker diarization")
async def diarize_meeting(
    db: Session = Depends(get_db_session),
    job: MeetingJob = Depends(get_job_ready_for_diarization)
):
    """Triggers the speaker diarization and mapping process."""
    db.add(job) # Re-bind object to session
    audio_file_path = Path(settings.SHARED_AUDIO_PATH) / job.request_id / f"{Path(job.original_filename).stem}_full.wav"
    if not audio_file_path.exists():
        raise HTTPException(status_code=404, detail="Assembled audio file not found.")

    job.status = "diarizing"
    db.commit()

    # --- FIX 2: Use send_task for decoupled dispatching ---
    celery_app.send_task("run_diarization_task", args=[job.id, str(audio_file_path)])
    
    await websocket_manager.broadcast_to_job(job.request_id, {"status": "diarizing"})
    return {"status": 202, "message": "Diarization process started."}

# ===================================================================
#   Real-time Status and Management Endpoints
# ===================================================================

@router.get("/{request_id}/status", response_model=MeetingJobResponseWrapper, summary="Get current meeting status")
async def get_meeting_status(
    db: Session = Depends(get_db_session),
    job: MeetingJob = Depends(get_owned_job_from_path)
):
    """Retrieves the complete current status of a meeting job."""
    db.add(job)
    formatted_data = _format_job_status(job, db)
    return MeetingJobResponseWrapper(data=formatted_data)


@router.websocket("/ws/{request_id}")
async def websocket_endpoint(websocket: WebSocket, request_id: str):
    """Establishes a WebSocket connection for real-time updates."""
    await websocket.accept()
    if request_id not in websocket_manager.active_connections:
        websocket_manager.active_connections[request_id] = []
    websocket_manager.active_connections[request_id].append(websocket)
    logger.info(f"WebSocket connected for request_id '{request_id}'.")
    try:
        with Session(engine) as session:
            job = session.exec(select(MeetingJob).where(MeetingJob.request_id == request_id)).first()
            if job:
                await websocket.send_json(_format_job_status(job, session))
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected for request_id '{request_id}'.")
    finally:
        websocket_manager.disconnect(websocket, request_id)


@router.patch("/{request_id}/info", response_model=MeetingJobResponseWrapper, summary="Update meeting metadata")
async def update_meeting_info(
    update_data: MeetingInfoUpdateRequest,
    db: Session = Depends(get_db_session),
    job: MeetingJob = Depends(get_owned_job_from_path)
):
    """Updates editable meeting metadata (name, type, host)."""
    # ... (This function is already correct and requires no changes) ...


@router.post("/{request_id}/language", response_model=MeetingJobResponseWrapper, summary="Change meeting language")
async def change_meeting_language(
    language_request: LanguageChangeRequest,
    db: Session = Depends(get_db_session),
    job: MeetingJob = Depends(get_owned_job_from_path)
):
    """Changes the active language and re-transcribes if necessary."""
    db.add(job)
    new_language = language_request.language
    if job.language == new_language:
        return MeetingJobResponseWrapper(data=_format_job_status(job, db))

    cached_transcript = db.exec(select(Transcription).where(Transcription.meeting_job_id == job.id, Transcription.language == new_language)).first()
    job.language = new_language
    
    if cached_transcript:
        if job.diarized_transcript: db.delete(job.diarized_transcript)
        job.status = "transcription_complete"
    else:
        audio_file_path = Path(settings.SHARED_AUDIO_PATH) / job.request_id / f"{Path(job.original_filename).stem}_full.wav"
        if not audio_file_path.exists():
            raise HTTPException(status_code=404, detail="Assembled audio file not found. Cannot re-transcribe.")
        job.status = "transcribing"
        
        # --- FIX 2: Use send_task for decoupled dispatching ---
        celery_app.send_task("run_transcription_task", args=[job.id, str(audio_file_path), new_language])

    db.commit()
    db.refresh(job)
    updated_status = _format_job_status(job, db)
    await websocket_manager.broadcast_to_job(job.request_id, updated_status)
    return MeetingJobResponseWrapper(message=f"Language changed to '{new_language}'.", data=updated_status)


@router.put("/{request_id}/transcript/plain", response_model=MeetingJobResponseWrapper, summary="Update the plain transcript")
async def update_plain_transcript(
    update_request: PlainTranscriptUpdateRequest,
    db: Session = Depends(get_db_session),
    job: MeetingJob = Depends(get_owned_job_from_path)
):
    """Overwrites the plain transcript and clears all downstream analysis data."""
    # ... (This function is already correct and requires no changes) ...

@router.delete("/{request_id}/cancel", status_code=status.HTTP_200_OK, summary="Cancel an ongoing meeting")
async def cancel_meeting(
    db: Session = Depends(get_db_session),
    job: MeetingJob = Depends(get_cancellable_job)
):
    """Deletes a job record and its associated files."""
    # ... (This function is already correct and requires no changes) ...

# ===================================================================
#   Analysis, Chat, and Download Endpoints
# ===================================================================

@router.post("/{request_id}/summary", response_model=SummaryResponse, summary="Generate a meeting summary")
async def generate_summary(
    summary_request: SummaryRequest,
    db: Session = Depends(get_db_session),
    job: MeetingJob = Depends(get_owned_job_from_path) 
):
    """Generates a summary based on the requested type, overwriting if it exists."""
    # ... (This function is already correct and requires no changes) ...

@router.post("/chat", response_model=ChatResponse, summary="Chat about the meeting content")
async def chat_with_meeting(
    chat_request: ChatRequest,
    db: Session = Depends(get_db_session)
):
    """Handles conversational queries about a meeting."""
    # ... (This function is already correct and requires no changes) ...

@router.get("/{request_id}/download/audio", summary="Download the original audio file")
async def download_audio_file(
    job: MeetingJob = Depends(get_owned_job_from_path)
):
    """Provides a direct download of the fully assembled meeting audio file."""
    # ... (This function is already correct and requires no changes) ...

@router.get("/{request_id}/download/document", summary="Generate and download a formal meeting document")
async def generate_and_download_document(
    job: MeetingJob = Depends(get_job_with_any_transcript),
    template_type: str = Query(..., enum=["bbh_hdqt", "nghi_quyet"]),
    db: Session = Depends(get_db_session)
):
    """Generates a DOCX document from a template using LLM-extracted data."""
    # ... (This function is already correct and requires no changes) ...
