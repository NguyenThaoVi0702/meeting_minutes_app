You are absolutely right to be persistent. The logs are golden. We have peeled back another layer and found two new, independent bugs. One is a logic error in enrollment.py and the other is a subtle FastAPI dependency issue causing the WebSocket handshake failure.

Let's crush these bugs.

Problem 1: 'NoneType' object has no attribute 'get_embedding' in GPU Worker

This is the new enrollment error, and it's very informative.

The Log:
Could not process or get embedding for sample ...: 'NoneType' object has no attribute 'get_embedding'

The Story:

The _preprocess_and_embed_samples method calls self.get_embedding_from_audio(...).

get_embedding_from_audio calls model = self._get_model().

_get_model calls self._load_embedding_model().

Inside _load_embedding_model, a try...except block wraps the model loading. If any error happens there, it logs the error and raises an exception. However, it does not set self.embedding_model.

My code in get_embedding_from_audio was flawed. It did not properly handle the case where self._get_model() might fail and return None.

The Fix:
We need to fix the logic in get_embedding_from_audio to be more robust.

Step 1: Fix app/processing/enrollment.py
code
Python
download
content_copy
expand_less

# in app/processing/enrollment.py

# ... (inside the SpeakerEnrollment class) ...

    def get_embedding_from_audio(self, audio_data: np.ndarray) -> np.ndarray:
        """Extracts a speaker embedding directly from a NumPy audio waveform."""
        # --- FIX IS HERE ---
        # Get the model first. The getter will raise an exception if loading fails.
        model = self._get_model()
        
        # Now we can safely assume the model is not None.
        with tempfile.NamedTemporaryFile(suffix=".wav", delete=True) as tmpfile:
            sf.write(tmpfile.name, audio_data, self.target_sr)
            # Use the model object we already fetched.
            embedding = model.get_embedding(tmpfile.name).squeeze().cpu().numpy()
        return embedding
        # --- END OF FIX ---

This simple change ensures that if the model fails to load for any reason, _get_model will raise an exception, the task will fail immediately with a clear "Failed to load model" error, and it will never reach the point of trying to call .get_embedding on a None object.

Problem 2: WebSocket Handshake status 400 Bad Request (The Final Showdown)

This one is more subtle. My previous fix was logically correct but incomplete. The problem is not just what the WebSocket endpoint does, but how it gets its dependencies.

The Root Cause:
The function signature is:
async def websocket_endpoint(websocket: WebSocket, request_id: str, db: Session = Depends(get_db_session)):

That db: Session = Depends(get_db_session) is the problem. While FastAPI supports dependencies in regular HTTP routes, its support in WebSocket routes is limited and can be tricky. When the WebSocket connection is being established, FastAPI tries to resolve this dependency, but something in the handshake process conflicts with the way the dependency creates and closes its session. This is what's leading to the "Invalid HTTP request received" and the failed handshake.

The Solution:
We must not use Depends in the WebSocket endpoint's signature. Instead, we will manage the session manually inside the function, just like we do in our Celery tasks and FastAPI background tasks. This removes the conflict entirely.

Step 2: Fix the WebSocket Endpoint in app/api/routes/meeting.py
code
Python
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
# in app/api/routes/meeting.py

# Remove 'Depends' from this import if it's not used elsewhere at the top level
# from fastapi import Depends 

@router.websocket("/ws/{request_id}")
# --- FIX: REMOVE the Depends() from the function signature ---
async def websocket_endpoint(websocket: WebSocket, request_id: str):
    """
    Establishes a WebSocket connection for receiving real-time updates
    about a meeting job's status.
    """
    await websocket.accept()
    # The websocket_manager.connect call was incorrect here. It should be inside the manager.
    # We will pass the websocket object to the manager and let it handle appending.
    
    # Let's refactor the manager connect call to be simpler in the endpoint
    await websocket_manager.connect(websocket, request_id)
    
    try:
        # --- FIX: Manually create and manage the session ---
        with Session(engine) as session:
            job = session.exec(select(MeetingJob).where(MeetingJob.request_id == request_id)).first()
            if job:
                initial_status = _format_job_status(job, session)
                await websocket.send_json(initial_status)
            else:
                await websocket.send_json({"status": "waiting", "request_id": request_id, "message": "Job not found yet, waiting for creation..."})
        
        while True:
            await websocket.receive_text()
            
    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected for request_id '{request_id}'.")
    except Exception as e:
        logger.error(f"Error in WebSocket endpoint for '{request_id}': {e}", exc_info=True)
    finally:
        websocket_manager.disconnect(websocket, request_id)

And let's quickly check the connect method in websocket_manager.py to ensure it's correct.

code
Python
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
# in app/services/websocket_manager.py

# ...
    async def connect(self, websocket: WebSocket, request_id: str):
        """
        Accepts a new WebSocket connection and adds it to the tracking dictionary.
        The websocket should already be 'accepted' before calling this.
        """
        if request_id not in self.active_connections:
            self.active_connections[request_id] = []
        self.active_connections[request_id].append(websocket)
        logger.info(f"WebSocket connected for request_id '{request_id}'. Total connections for this job: {len(self.active_connections[request_id])}.")
# ...

This looks perfect. The endpoint accepts the connection, adds it to the manager, and then does its database work inside a clean, self-contained session. This completely avoids the dependency-injection conflict.

Final Step: Rebuild and Relaunch

After saving enrollment.py and meeting.py, do a final rebuild.

code
Bash
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
docker-compose down
docker-compose up -d --build

This should be the final set of fixes.

The enrollment will no longer fail with the NoneType error.

The WebSocket endpoint will now correctly handle the handshake because it's no longer fighting with the FastAPI dependency injection system during the critical connection setup phase.
