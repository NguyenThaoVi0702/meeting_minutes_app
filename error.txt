# In /app/utils.py

import logging
import re
import markdown
from bs4 import BeautifulSoup
from docxtpl import DocxTemplate, Subdoc
from docx.enum.text import WD_ALIGN_PARAGRAPH

logger = logging.getLogger(__name__)

# --- NEW, MORE ROBUST UTILITY FUNCTIONS ---

def _process_inline_formatting(paragraph, contents):
    """
    Processes a list of BeautifulSoup contents (strings and tags) into
    formatted docx runs within a single paragraph.
    This version is robust and can handle leftover Markdown **bold** syntax
    within plain text strings.
    """
    for item in contents:
        # If the item is a standard HTML tag for formatting
        if hasattr(item, 'name') and item.name:
            if item.name in ['strong', 'b']:
                run = paragraph.add_run(item.get_text(strip=True))
                run.bold = True
            elif item.name in ['em', 'i']:
                run = paragraph.add_run(item.get_text(strip=True))
                run.italic = True
            else: # Fallback for other tags
                paragraph.add_run(item.get_text(strip=True))
        
        # If the item is just a string, check it for leftover Markdown
        elif isinstance(item, str):
            # Split the string by the bold markers `**`
            parts = re.split(r'(\*\*.*?\*\*)', item)
            for part in parts:
                if not part:
                    continue
                # If the part is bold, strip the markers and add as a bold run
                if part.startswith('**') and part.endswith('**'):
                    run = paragraph.add_run(part[2:-2])
                    run.bold = True
                # Otherwise, add as a regular run
                else:
                    paragraph.add_run(part)

def markdown_to_subdoc(template: DocxTemplate, md_text: str) -> Subdoc:
    """
    Converts a Markdown string into a docxtpl Subdoc object, preserving
    structure and applying specific formatting like justification.
    """
    # Convert markdown to a clean HTML string
    html = markdown.markdown(md_text.strip(), extensions=['extra'])
    
    # Parse the HTML
    soup = BeautifulSoup(html, 'html.parser')

    # Create a new subdocument from the main template
    subdoc = template.new_subdoc()

    # Iterate through the top-level HTML tags
    for element in soup.contents:
        if not hasattr(element, 'name') or not element.name:
            continue

        p = None # Initialize paragraph variable

        if element.name in ['h1', 'h2', 'h3', 'h4']:
            level = int(element.name[1:])
            p = subdoc.add_heading(level=level)
            _process_inline_formatting(p, element.contents)
            # <<< NO justification for headings >>>

        elif element.name == 'p':
            p = subdoc.add_paragraph()
            _process_inline_formatting(p, element.contents)
            # <<< SET justification for paragraphs >>>
            p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

        elif element.name == 'ul':
            for li in element.find_all('li', recursive=False):
                p = subdoc.add_paragraph(style='List Bullet')
                _process_inline_formatting(p, li.contents)
                # <<< SET justification for list items >>>
                p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
        
        elif element.name == 'ol':
            for i, li in enumerate(element.find_all('li', recursive=False)):
                # Manually create the numbered list item text
                p = subdoc.add_paragraph()
                # We add the number as a separate run to avoid formatting issues
                p.add_run(f"{i+1}.\t")
                _process_inline_formatting(p, li.contents)
                # <<< SET justification for list items >>>
                p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
                
    return subdoc
