# In /app/utils.py

# ... (keep all the imports and the _process_inline_formatting function as is) ...

def markdown_to_subdoc(template: DocxTemplate, md_text: str) -> Subdoc:
    """
    Converts a Markdown string into a docxtpl Subdoc object, correctly
    handling nested tags and applying specific formatting.
    """
    # Convert markdown to a clean HTML string
    html = markdown.markdown(md_text.strip(), extensions=['extra'])
    
    # Parse the HTML
    soup = BeautifulSoup(html, 'html.parser')

    # Create a new subdocument from the main template
    subdoc = template.new_subdoc()

    # Iterate through the top-level HTML tags
    for element in soup.contents:
        if not hasattr(element, 'name') or not element.name:
            continue

        p = None # Initialize paragraph variable

        # --- HEADING AND PARAGRAPH LOGIC (remains the same) ---
        if element.name in ['h1', 'h2', 'h3', 'h4']:
            level = int(element.name[1:])
            p = subdoc.add_heading(level=level)
            _process_inline_formatting(p, element.contents)

        elif element.name == 'p':
            p = subdoc.add_paragraph()
            _process_inline_formatting(p, element.contents)
            p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
        
        # --- LIST LOGIC (THIS IS THE CRITICAL FIX) ---
        elif element.name in ['ul', 'ol']:
            # Determine the style based on the list type
            list_style = 'List Bullet' if element.name == 'ul' else None

            for li in element.find_all('li', recursive=False):
                if list_style:
                    p = subdoc.add_paragraph(style=list_style)
                else: # Manual handling for ordered lists
                    p = subdoc.add_paragraph()

                # <<< THE FIX IS HERE >>>
                # The markdown library often wraps the content of an <li> in a <p> tag.
                # We must find that inner <p> and process ITS content, not the <li>'s.
                p_in_li = li.find('p')
                content_to_process = p_in_li.contents if p_in_li else li.contents
                
                # Manually add number for ordered lists if not using a style
                if element.name == 'ol':
                     # We find the index of the current 'li' within its parent 'ol'
                    item_index = element.find_all('li', recursive=False).index(li)
                    p.add_run(f"{item_index + 1}.\t")

                _process_inline_formatting(p, content_to_process)
                p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
                
    return subdoc
