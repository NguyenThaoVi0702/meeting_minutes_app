# In /app/utils.py

import logging
import re
from docxtpl import DocxTemplate, Subdoc
from docx.enum.text import WD_ALIGN_PARAGRAPH

logger = logging.getLogger(__name__)

def _add_formatted_text_to_paragraph(paragraph, text_content):
    """
    Splits a line of text by the bold markers `**` and adds runs
    to a paragraph with the correct formatting.
    """
    # This regex splits the string by the bold markers, but keeps the markers
    # e.g., "This is **bold**" -> ['This is ', '**bold**', '']
    parts = re.split(r'(\*\*.*?\*\*)', text_content)
    
    for part in parts:
        if not part:
            continue
        
        # If the part is bold, strip the markers and add it as a bold run
        if part.startswith('**') and part.endswith('**'):
            run = paragraph.add_run(part[2:-2])
            run.bold = True
        # Otherwise, add it as a regular run
        else:
            paragraph.add_run(part)

def markdown_to_subdoc(template: DocxTemplate, md_text: str) -> Subdoc:
    """
    Directly parses a Markdown string (supporting lists, headings, and bold)
    into a docxtpl Subdoc object, applying justification.
    This version does NOT use the markdown or beautifulsoup libraries.
    """
    subdoc = template.new_subdoc()
    clean_text = md_text.strip()
    
    for line in clean_text.split('\n'):
        stripped_line = line.strip()
        if not stripped_line:
            continue

        p = None  # This will hold our paragraph object

        # --- Handle Block Elements (Lists, Headings, Paragraphs) ---

        # Unordered Lists
        if stripped_line.startswith(('* ', '- ')):
            p = subdoc.add_paragraph(style='List Bullet')
            content = stripped_line[2:]
            _add_formatted_text_to_paragraph(p, content)
            p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
        
        # Ordered Lists (simple version)
        elif re.match(r'^\d+\.\s+', stripped_line):
            p = subdoc.add_paragraph()
            # Find where the text content actually starts
            content_match = re.search(r'^\d+\.\s+(.*)', stripped_line)
            content = content_match.group(1) if content_match else ''
            # Manually add the list number part
            p.add_run(stripped_line[:len(stripped_line) - len(content)])
            # Add the rest of the formatted content
            _add_formatted_text_to_paragraph(p, content)
            p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

        # Headings
        elif stripped_line.startswith('#'):
            level = len(stripped_line) - len(stripped_line.lstrip('#'))
            level = max(1, min(4, level)) # Clamp level between 1 and 4
            content = stripped_line.lstrip('# ').strip()
            p = subdoc.add_heading(level=level)
            _add_formatted_text_to_paragraph(p, content)
            # Headings are not justified
        
        # Regular Paragraphs
        else:
            p = subdoc.add_paragraph()
            _add_formatted_text_to_paragraph(p, stripped_line)
            p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

    return subdoc
