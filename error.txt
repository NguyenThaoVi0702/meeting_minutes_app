# In /app/utils.py

import logging
import re
from docxtpl import DocxTemplate, Subdoc
from docx.enum.text import WD_ALIGN_PARAGRAPH

logger = logging.getLogger(__name__)

def _add_formatted_text_to_paragraph(paragraph, text_content):
    """
    Splits a line of text by the bold markers `**` and adds runs
    to a paragraph with the correct formatting. This function is robust
    and handles multiple bold sections in one line.
    """
    # Regex to split the string by bold markers, but keep the markers for processing
    parts = re.split(r'(\*\*.*?\*\*)', text_content)
    
    for part in parts:
        if not part:
            continue
        
        # If the part is marked as bold, strip the markers and add it as a bold run
        if part.startswith('**') and part.endswith('**'):
            run = paragraph.add_run(part[2:-2])
            run.bold = True
        # Otherwise, add it as a regular text run
        else:
            paragraph.add_run(part)

def markdown_to_subdoc(template: DocxTemplate, md_text: str) -> Subdoc:
    """
    Directly parses a Markdown string into a docxtpl Subdoc object.
    This version correctly handles messy AI output where structural elements
    (like headings) might also be wrapped in bold markers.
    """
    subdoc = template.new_subdoc()
    clean_text = md_text.strip()
    
    for line in clean_text.split('\n'):
        stripped_line = line.strip()
        if not stripped_line:
            continue

        # --- 1. Determine the Structure First ---
        
        content = stripped_line
        p = None

        # Check for headings, even if they are wrapped in bold
        if stripped_line.lstrip(' *').startswith('#'):
            level = len(stripped_line) - len(stripped_line.lstrip(' #*'))
            level = max(1, min(4, level)) # Clamp level between 1 and 4
            p = subdoc.add_heading(level=level)
            content = stripped_line.lstrip(' #*').strip()

        # Check for unordered lists, even if the content is bold
        elif stripped_line.startswith(('* ', '- ')):
            p = subdoc.add_paragraph(style='List Bullet')
            content = stripped_line[2:] # Get content after '- '
            p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

        # Check for ordered lists
        elif re.match(r'^\d+\.\s+', stripped_line):
            p = subdoc.add_paragraph()
            match = re.match(r'^(\d+\.\s+)(.*)', stripped_line)
            list_marker, content = match.groups()
            p.add_run(list_marker) # Add the "1. " part
            p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
        
        # Default to a regular paragraph
        else:
            p = subdoc.add_paragraph()
            p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

        # --- 2. Apply Inline Formatting to the Determined Content ---
        _add_formatted_text_to_paragraph(p, content)
            
    return subdoc
