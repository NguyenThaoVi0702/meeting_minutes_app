# In app/utils.py

import logging
import re
from docxtpl import DocxTemplate, Subdoc
from docx.enum.text import WD_ALIGN_PARAGRAPH
from typing import List, Dict, Any

logger = logging.getLogger(__name__)

# --------------------- FIX #1: ADD XML SANITIZER FUNCTION ---------------------
def sanitize_xml_string(text: str) -> str:
    """
    Removes illegal XML characters from a string to prevent document corruption.
    """
    if not isinstance(text, str):
        return text
    # This regex matches any character that is not a valid XML 1.0 character.
    # See: https://www.w3.org/TR/xml/#charsets
    return re.sub(
        r'[^\x09\x0A\x0D\x20-\uD7FF\uE000-\uFFFD\U00010000-\U0010FFFF]',
        '',
        text
    )
# -----------------------------------------------------------------------------

def _add_runs_with_bolding(paragraph, text_content: str):
    """
    Parses a string containing <b>...</b> tags and adds formatted runs
    to the given paragraph object.
    """
    # Sanitize the entire input string first.
    safe_content = sanitize_xml_string(text_content)
    parts = re.split(r'(<b>|</b>)', safe_content)
    
    is_bold = False
    for part in parts:
        if part == '<b>':
            is_bold = True
            continue
        elif part == '</b>':
            is_bold = False
            continue
        
        if part: 
            # --------------------- FIX #1 (continued): Apply sanitizer ---------------------
            # Although the whole string is sanitized, we ensure each part is clean.
            run = paragraph.add_run(sanitize_xml_string(part))
            # -------------------------------------------------------------------------------
            run.bold = is_bold

def create_subdoc_from_structured_data(template: DocxTemplate, structured_data: List[Dict[str, Any]]) -> Subdoc:
    """
    Takes a list of structured content objects (e.g., from an LLM) and
    builds a docxtpl Subdoc object with appropriate formatting by applying
    named paragraph styles defined in the Word template.
    """
    subdoc = template.new_subdoc()

    # --------------------- FIX #2: HANDLE NULL FOR LIST FIELDS ---------------------
    # If the LLM returns `null` for a field that should be a list,
    # treat it as an empty list to prevent errors.
    if structured_data is None:
        structured_data = []
    # ---------------------------------------------------------------------------

    if not isinstance(structured_data, list):
        if isinstance(structured_data, str) and structured_data:
             # Also sanitize here for safety.
             p = subdoc.add_paragraph(sanitize_xml_string(str(structured_data)))
             p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
        return subdoc

    for item in structured_data:
        content_type = item.get("type", "paragraph")
        content = item.get("content", "")
        
        p = None
        if content_type == "heading":
            p = subdoc.add_heading(level=3)
        
        elif content_type == "alpha_bullet":
            p = subdoc.add_paragraph(style='AlphabetListPara')
            
        elif content_type == "bullet":
            p = subdoc.add_paragraph(style='DashListPara')

        else: 
            p = subdoc.add_paragraph()

        # The _add_runs_with_bolding function will now handle sanitization.
        _add_runs_with_bolding(p, content)
        
        if content_type != "heading":
            p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

    return subdoc
