# test_api.py (Comprehensive E2E Test Suite - WebSocket Fix)
import requests
import os
import time
import csv
import glob
import json
import threading
import websocket
from requests.exceptions import JSONDecodeError, RequestException
from urllib.parse import quote

# --- CONFIGURATION ---
API_BASE_URL = "http://api:8072/api/v1"
SPEAKER_METADATA_PATH = "speaker_metadata.csv"
SPEAKER_AUDIO_DIR = "speaker_audio"
MEETING_AUDIO_DIR = "meeting_to"
TEST_USERNAME = "test_user_01"
MAX_SAMPLES_PER_SPEAKER = 20
UPLOAD_TIMEOUT_SECONDS = 60
DOWNLOAD_DIR = "/app/downloads"


WEBSOCKET_DONE = threading.Event()

# --- HELPER FUNCTIONS ---

def print_response(response, step_name):
    print(f"  -> [{step_name}] Status: {response.status_code}")
    try:
        print(f"     Response: {json.dumps(response.json(), indent=2, ensure_ascii=False)}")
    except JSONDecodeError:
        print(f"     Response (non-JSON): {response.text[:500]}...")

def read_speaker_metadata():
    metadata = {}
    with open(SPEAKER_METADATA_PATH, mode='r', encoding='utf-8-sig') as infile:
        reader = csv.DictReader(infile)
        for row in reader:
            if 'folder_name' in row: metadata[row['folder_name']] = row
    print(f"Loaded metadata for {len(metadata)} speakers from CSV.")
    return metadata

def group_meeting_chunks():
    meetings = {}
    search_path = os.path.join(MEETING_AUDIO_DIR, '*.wav')
    for chunk_path in glob.glob(search_path):
        filename = os.path.basename(chunk_path)
        meeting_name = "_".join(filename.split('_')[:-1])
        if meeting_name not in meetings: meetings[meeting_name] = []
        meetings[meeting_name].append(chunk_path)
    for name, chunks in meetings.items():
        chunks.sort(key=lambda x: int(os.path.basename(x).split('_')[-1].split('.')[0]))
    print(f"Found {len(meetings)} meetings to process.")
    return meetings

def find_audio_files(directory):
    patterns = ['*.wav', '*.mp3', '*.m4a', '*.flac', '*.ogg']
    files = []
    for pattern in patterns:
        files.extend(glob.glob(os.path.join(directory, pattern)))
    return files

# <<< FIX IS HERE
def listen_on_websocket(request_id):
    encoded_request_id = quote(request_id)
    ws_url = f"{API_BASE_URL.replace('http', 'ws')}/meeting/ws/{encoded_request_id}"
    print(f"\n[WebSocket] Connecting to {ws_url}...")
    def on_message(ws, message):
        data = json.loads(message)
        status = data.get('status')
        print(f"\n[WebSocket] === STATUS UPDATE: {status} ===")
        print(json.dumps(data, indent=2, ensure_ascii=False))
        if status in ['transcription_complete', 'completed', 'failed', 'cancelled']:
            WEBSOCKET_DONE.set()
            ws.close() # This line is CRITICAL to stop the listener thread.

    def on_error(ws, error):
        print(f"[WebSocket] Error: {error}")
        WEBSOCKET_DONE.set()

    def on_close(ws, c, m):
        print("[WebSocket] Connection closed.")

    def on_open(ws):
        print("[WebSocket] Connection opened.")

    ws_app = websocket.WebSocketApp(ws_url, on_open=on_open, on_message=on_message, on_error=on_error, on_close=on_close)
    ws_app.run_forever()


def run_full_test():
    os.makedirs(DOWNLOAD_DIR, exist_ok=True)
    metadata = read_speaker_metadata()
    meetings = group_meeting_chunks()
    speaker_to_delete = None

    # Step 1: Enroll Speakers
    print("\n--- STEP 1: ENROLLING ALL SPEAKERS ---")
    speaker_folders = [d for d in os.listdir(SPEAKER_AUDIO_DIR) if os.path.isdir(os.path.join(SPEAKER_AUDIO_DIR, d))]
    for folder_name in speaker_folders:
        meta = metadata.get(folder_name)
        if not meta or not meta.get('user_ad'): continue
        user_ad = meta['user_ad']
        audio_files = find_audio_files(os.path.join(SPEAKER_AUDIO_DIR, folder_name))
        if not audio_files: continue
        files_to_upload_paths = audio_files[:MAX_SAMPLES_PER_SPEAKER]
        files_to_upload_tuples = [('files', (os.path.basename(f), open(f, 'rb'))) for f in files_to_upload_paths]
        payload = {'metadata': json.dumps({"display_name": meta.get('display_name', folder_name), "user_ad": user_ad})}
        print(f"\nEnrolling '{user_ad}' with {len(files_to_upload_paths)} samples...")
        try:
            response = requests.post(f"{API_BASE_URL}/speaker/", data=payload, files=files_to_upload_tuples, timeout=UPLOAD_TIMEOUT_SECONDS)
            print_response(response, "Enroll Speaker")
            if response.status_code == 202 and speaker_to_delete is None:
                speaker_to_delete = user_ad
        except RequestException as e:
            print(f"  -> ERROR: Connection error during enrollment: {e}")
        time.sleep(2)

    # Step 2: Test Speaker Management
    print("\n\n--- STEP 2: TESTING ALL SPEAKER CRUD ENDPOINTS ---")
    if speaker_to_delete:
        print(f"\nTesting: DELETE /speaker/{speaker_to_delete}")
        delete_response = requests.delete(f"{API_BASE_URL}/speaker/{speaker_to_delete}")
        print_response(delete_response, "Delete Speaker")

    # Step 3 & 4: Process Meeting
    print("\n\n--- STEP 3 & 4: PROCESSING A FULL MEETING ---")
    if not meetings: return
    meeting_name, chunks = list(meetings.items())[0]
    request_id = f"test_{meeting_name}_{int(time.time())}"
    encoded_request_id = quote(request_id)

    start_payload = { 'requestId': request_id, 'username': TEST_USERNAME, 'language': 'vi', 'filename': f"{meeting_name}.wav", 'bbhName': "Test BBH Name", 'Type': "Test Type", 'Host': "Test Host" }
    requests.post(f"{API_BASE_URL}/meeting/start-bbh", data=start_payload)
    for i, chunk_path in enumerate(chunks):
        is_last = (i == len(chunks) - 1)
        chunk_payload = {'requestId': request_id, 'isLastChunk': str(is_last)}
        files = {'FileData': (os.path.basename(chunk_path), open(chunk_path, 'rb'), 'audio/wav')}
        requests.post(f"{API_BASE_URL}/meeting/upload-file-chunk", data=chunk_payload, files=files)

    print("\n--- WAITING FOR TRANSCRIPTION VIA WEBSOCKET ---")
    ws_thread = threading.Thread(target=listen_on_websocket, args=(request_id,))
    ws_thread.start()
    WEBSOCKET_DONE.wait(timeout=600)
    ws_thread.join()

    requests.post(f"{API_BASE_URL}/meeting/{encoded_request_id}/diarize?username={TEST_USERNAME}")

    WEBSOCKET_DONE.clear()
    print("\n--- WAITING FOR DIARIZATION VIA WEBSOCKET ---")
    ws_thread = threading.Thread(target=listen_on_websocket, args=(request_id,))
    ws_thread.start()
    WEBSOCKET_DONE.wait(timeout=600)
    ws_thread.join()

    # Step 5: Analysis and Downloads
    print("\n\n--- STEP 5: TESTING ANALYSIS AND DOWNLOADS ---")
    audio_dl_response = requests.get(f"{API_BASE_URL}/meeting/{encoded_request_id}/download/audio?username={TEST_USERNAME}")
    if audio_dl_response.status_code == 200:
        audio_save_path = os.path.join(DOWNLOAD_DIR, f"{request_id}_audio.wav")
        with open(audio_save_path, 'wb') as f: f.write(audio_dl_response.content)
        print(f"  -> [Download Audio] OK. File saved inside container at {audio_save_path}")

    document_types_to_test = ["bbh_hdqt", "nghi_quyet"]
    for doc_type in document_types_to_test:
        print(f"\nTesting document download (type: {doc_type})")
        doc_params = {'username': TEST_USERNAME, 'template_type': doc_type}
        doc_dl_response = requests.get(f"{API_BASE_URL}/meeting/{encoded_request_id}/download/document", params=doc_params)
        if doc_dl_response.status_code == 200:
            doc_save_path = os.path.join(DOWNLOAD_DIR, f"{request_id}_{doc_type}.docx")
            with open(doc_save_path, 'wb') as f: f.write(doc_dl_response.content)
            print(f"  -> [Download Document] OK. File saved inside container at {doc_save_path}")
        else:
            print_response(doc_dl_response, f"Download {doc_type}")

    print("\n\n--- ALL TESTS COMPLETE ---")

if __name__ == "__main__":
    run_full_test()
