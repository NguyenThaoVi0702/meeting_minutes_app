import requests
import os
import time
import json
import threading
import websocket
from urllib.parse import quote
from requests.exceptions import JSONDecodeError

# --- CONFIGURATION ---
# IMPORTANT: Adjust these values to match your environment
API_BASE_URL = "http://localhost:8072/api/v1"
MEETING_AUDIO_PATH = "test_audio/sample_meeting.wav"  # <-- Make sure this file exists
TEST_USERNAME = "test_user_integration"
DOWNLOAD_DIR = "test_downloads"

# Global event to signal when a WebSocket task is done
WEBSOCKET_DONE = threading.Event()

# --- HELPER FUNCTIONS ---

def print_step(title):
    print("\n" + "="*80)
    print(f"--- STEP: {title.upper()} ---")
    print("="*80)

def print_scenario(title):
    print("\n" + "-"*60)
    print(f"--> SCENARIO: {title}")
    print("-"*60)

def print_response(response, step_name):
    print(f"  -> [{step_name}] Status: {response.status_code}")
    try:
        # Limit long responses for readability
        response_json = response.json()
        if "summary_content" in response_json and len(response_json["summary_content"]) > 300:
            response_json["summary_content"] = response_json["summary_content"][:300] + "..."
        if "response" in response_json and len(response_json["response"]) > 300:
            response_json["response"] = response_json["response"][:300] + "..."
            
        print(f"     Response: {json.dumps(response_json, indent=2, ensure_ascii=False)}")
    except (JSONDecodeError, TypeError):
        print(f"     Response (non-JSON or not serializable): {response.text[:500]}...")

def listen_on_websocket(request_id):
    """Connects to the WebSocket and waits for a terminal status update."""
    encoded_request_id = quote(request_id)
    ws_url = f"{API_BASE_URL.replace('http', 'ws')}/meeting/ws/{encoded_request_id}"
    print(f"\n[WebSocket] Connecting to {ws_url}...")

    def on_message(ws, message):
        data = json.loads(message)
        status = data.get('status')
        print(f"\n[WebSocket] ===> STATUS UPDATE: {status} <===")
        if status in ['completed', 'failed', 'cancelled', 'transcription_complete']:
            print(f"[WebSocket] Received terminal status '{status}'. Closing connection.")
            WEBSOCKET_DONE.set()
            ws.close()

    def on_error(ws, error):
        print(f"[WebSocket] Error: {error}")
        WEBSOCKET_DONE.set()

    def on_close(ws, close_status_code, close_msg):
        print("[WebSocket] Connection closed.")
        if not WEBSOCKET_DONE.is_set():
            WEBSOCKET_DONE.set() # Ensure we don't wait forever if connection closes unexpectedly

    def on_open(ws):
        print("[WebSocket] Connection opened. Waiting for status updates...")

    ws_app = websocket.WebSocketApp(ws_url, on_open=on_open, on_message=on_message, on_error=on_error, on_close=on_close)
    ws_app.run_forever()

# --- MAIN TEST FUNCTION ---

def run_full_meeting_test():
    if not os.path.exists(MEETING_AUDIO_PATH):
        print(f"ERROR: Audio file not found at '{MEETING_AUDIO_PATH}'. Please check the path.")
        return
        
    os.makedirs(DOWNLOAD_DIR, exist_ok=True)
    
    request_id = f"integration_test_{int(time.time())}"
    encoded_request_id = quote(request_id)
    print(f"Starting full integration test with Request ID: {request_id}")

    # --- 1. START MEETING & UPLOAD AUDIO ---
    print_step("START MEETING AND UPLOAD AUDIO")
    start_payload = {
        'requestId': request_id,
        'username': TEST_USERNAME,
        'language': 'vi',
        'filename': os.path.basename(MEETING_AUDIO_PATH),
        'bbhName': "Integration Test Meeting",
        'Type': "Test",
        'Host': "Automated Tester"
    }
    start_res = requests.post(f"{API_BASE_URL}/meeting/start-bbh", data=start_payload)
    print_response(start_res, "Start BBH")

    upload_payload = {'requestId': request_id, 'isLastChunk': 'True'}
    with open(MEETING_AUDIO_PATH, 'rb') as f:
        files = {'FileData': (os.path.basename(MEETING_AUDIO_PATH), f, 'audio/wav')}
        upload_res = requests.post(f"{API_BASE_URL}/meeting/upload-file-chunk", data=upload_payload, files=files)
        print_response(upload_res, "Upload Chunk (Last)")

    # --- 2. WAIT FOR TRANSCRIPTION VIA WEBSOCKET ---
    print_step("WAITING FOR TRANSCRIPTION")
    ws_thread = threading.Thread(target=listen_on_websocket, args=(request_id,))
    ws_thread.start()
    WEBSOCKET_DONE.wait(timeout=600) # 10-minute timeout
    ws_thread.join()
    WEBSOCKET_DONE.clear()

    # --- 3. TRIGGER & WAIT FOR DIARIZATION VIA WEBSOCKET ---
    print_step("TRIGGER AND WAIT FOR DIARIZATION")
    diarize_res = requests.post(f"{API_BASE_URL}/meeting/{encoded_request_id}/diarize?username={TEST_USERNAME}")
    print_response(diarize_res, "Trigger Diarization")

    ws_thread_2 = threading.Thread(target=listen_on_websocket, args=(request_id,))
    ws_thread_2.start()
    WEBSOCKET_DONE.wait(timeout=600)
    ws_thread_2.join()
    WEBSOCKET_DONE.clear()

    # --- 4. GENERATE AND DOWNLOAD ALL SUMMARY TYPES ---
    print_step("GENERATE AND DOWNLOAD ALL SUMMARY TYPES")
    summary_types_to_test = ['topic', 'speaker', 'summary_bbh_hdqt', 'summary_nghi_quyet']
    for summary_type in summary_types_to_test:
        print(f"\n--- Testing generation and download for: '{summary_type}' ---")
        # Generate (or get) the summary
        summary_payload = {"summary_type": summary_type}
        summary_res = requests.post(f"{API_BASE_URL}/meeting/{encoded_request_id}/summary?username={TEST_USERNAME}", json=summary_payload)
        print_response(summary_res, f"Generate '{summary_type}' Summary")

        # Download the summary
        doc_params = {'username': TEST_USERNAME, 'summary_type': summary_type}
        doc_dl_res = requests.get(f"{API_BASE_URL}/meeting/{encoded_request_id}/download/document", params=doc_params)
        if doc_dl_res.status_code == 200:
            save_path = os.path.join(DOWNLOAD_DIR, f"{request_id}_{summary_type}.docx")
            with open(save_path, 'wb') as f:
                f.write(doc_dl_res.content)
            print(f"  -> [Download Document '{summary_type}'] SUCCESS. File saved to {save_path}")
        else:
            print_response(doc_dl_res, f"Download '{summary_type}' Document")
        time.sleep(1) # Small delay

    # --- 5. TEST CHAT EDITING SCENARIOS ---
    print_step("TESTING CHAT EDITING SCENARIOS")

    # SCENARIO 1: Happy Path - Edit an existing summary ('topic')
    print_scenario("Edit an existing summary ('topic')")
    chat_payload_1 = {
        "requestId": request_id,
        "username": TEST_USERNAME,
        "message": "Hãy sửa lại tóm tắt theo chủ đề, thêm vào ý 'Tất cả các thành viên đồng ý với kế hoạch ngân sách quý 4'."
    }
    chat_res_1 = requests.post(f"{API_BASE_URL}/meeting/chat", json=chat_payload_1)
    print_response(chat_res_1, "Chat Edit 'topic'")
    print("  -> VERIFY: The response should be the full, updated 'topic' summary including the new sentence.")

    # SCENARIO 2: State Check - Try to edit a summary that has been disabled ('action_items')
    print_scenario("Attempt to edit a disabled/non-existent summary type ('action_items')")
    chat_payload_2 = {
        "requestId": request_id,
        "username": TEST_USERNAME,
        "message": "Sửa lại danh sách các công việc cần làm cho tôi."
    }
    chat_res_2 = requests.post(f"{API_BASE_URL}/meeting/chat", json=chat_payload_2)
    print_response(chat_res_2, "Chat Edit non-existent 'action_items'")
    print("  -> VERIFY: The response should be a message asking the user to generate the summary first.")

    # SCENARIO 3: Ambiguity - Ask to edit without specifying which summary
    print_scenario("Ask to edit an ambiguous summary")
    chat_payload_3 = {
        "requestId": request_id,
        "username": TEST_USERNAME,
        "message": "Sửa lại bản tóm tắt này đi."
    }
    chat_res_3 = requests.post(f"{API_BASE_URL}/meeting/chat", json=chat_payload_3)
    print_response(chat_res_3, "Chat Edit Ambiguous")
    print("  -> VERIFY: The response should be a question asking the user to clarify WHICH summary.")
    
    # SCENARIO 4: General Question - Ask a question that should not trigger an edit
    print_scenario("Ask a general question (no edit)")
    chat_payload_4 = {
        "requestId": request_id,
        "username": TEST_USERNAME,
        "message": "Cuộc họp đã thảo luận về những chủ đề chính nào?"
    }
    chat_res_4 = requests.post(f"{API_BASE_URL}/meeting/chat", json=chat_payload_4)
    print_response(chat_res_4, "Chat General Question")
    print("  -> VERIFY: The response should be a conversational answer, NOT a full summary block.")

    print("\n\n--- ALL TESTS COMPLETE ---")

if __name__ == "__main__":
    run_full_meeting_test()
