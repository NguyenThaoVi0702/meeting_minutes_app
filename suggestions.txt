    # Wait for transcription
    print("\n--- WAITING FOR TRANSCRIPTION VIA WEBSOCKET ---")
    ws_thread = threading.Thread(target=listen_on_websocket, args=(request_id,))
    ws_thread.start()
    WEBSOCKET_DONE.wait(timeout=600)
    ws_thread.join()

    # <<< START OF NEW CODE BLOCK >>>

    # Get the status to extract the plain transcript
    print(f"\nFetching status to display full transcript text...")
    status_response = requests.get(f"{API_BASE_URL}/meeting/{encoded_request_id}/status?username={TEST_USERNAME}")
    
    if status_response.status_code == 200:
        try:
            response_data = status_response.json()
            segments = response_data.get('data', {}).get('plain_transcript')
            
            if segments and isinstance(segments, list):
                # Use a list comprehension to get the 'text' from each segment and join them
                full_transcript_text = "\n".join([seg['text'] for seg in segments])
                
                print("\n===================================================")
                print("   CONCATENATED FULL TRANSCRIPT (PLAIN TEXT)   ")
                print("===================================================")
                print(full_transcript_text)
                print("===================================================\n")
            else:
                print("\n--- Could not find 'plain_transcript' data in the status response. ---\n")
        except (JSONDecodeError, KeyError) as e:
            print(f"\n--- Error processing status response for transcript concatenation: {e} ---\n")
    else:
        print(f"\n--- Failed to fetch status for transcript concatenation (Status: {status_response.status_code}) ---\n")

    # <<< END OF NEW CODE BLOCK >>>

    # Trigger and wait for diarization
    requests.post(f"{API_BASE_URL}/meeting/{encoded_request_id}/diarize?username={TEST_USERNAME}")
