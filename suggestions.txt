Of course. This is a great feature to add for providing more context to the AI. Here is the quickest way to modify your code to include meeting_members.

Since you are okay with recreating the database tables, this process will be very fast and will not require a complex database migration.

Step 1: Update the Database Model

First, we need to add a field to the MeetingJob table to store the list of names. We'll use a JSONB column in PostgreSQL, which is perfect for storing lists.

File to Edit: app/db/models.py

code
Python
download
content_copy
expand_less
# app/db/models.py

import uuid
from datetime import datetime
# --- ADD 'List' TO THIS IMPORT ---
from typing import Optional, List, Dict, Any

from sqlalchemy import Column, Text
# --- ADD 'JSONB' TO THIS IMPORT ---
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.sql import func
from sqlmodel import SQLModel, Field, Relationship

# ... (other models remain the same)

class MeetingJob(SQLModel, table=True):
    """
    The central table for a meeting session. It tracks metadata,
    and links to all related data like transcripts, summaries, etc.
    """
    id: Optional[int] = Field(default=None, primary_key=True)
    request_id: str = Field(unique=True, index=True)
    user_id: int = Field(foreign_key="user.id")
    
    # --- Editable Meeting Info ---
    original_filename: str
    bbh_name: str
    meeting_type: str
    meeting_host: str
    
    # --- ADD THIS NEW FIELD ---
    meeting_members: Optional[List[str]] = Field(default=None, sa_column=Column(JSONB))
    # --- END OF ADDITION ---

    language: str = Field(default="vi", description="The currently active language for this meeting.")
    # ... (rest of the model remains the same)
Step 2: Update the API Input Schema

Next, allow the meeting_members list to be updated via the /info endpoint.

File to Edit: app/schemas/meeting.py

code
Python
download
content_copy
expand_less
# app/schemas/meeting.py

# ... (imports remain the same)

class MeetingInfoUpdateRequest(BaseModel):
    """
    Schema for updating the metadata of a meeting. All fields are optional
    so the user can update one or more fields at a time.
    """
    bbh_name: Optional[str] = None
    meeting_type: Optional[str] = None
    meeting_host: Optional[str] = None
    # --- ADD THIS NEW FIELD ---
    meeting_members: Optional[List[str]] = None
    # --- END OF ADDITION ---

# ... (rest of the file remains the same)
Step 3: Modify the API Endpoints

Now, we'll update the endpoints to accept and use the new meeting_members field.

File to Edit: app/api/routes/meeting.py

code
Python
download
content_copy
expand_less
# app/api/routes/meeting.py

# --- MAKE SURE 'json' IS IMPORTED ---
import json
import logging
# ... (other imports remain the same)


# ...

# ===================================================================
#   Core Meeting Workflow Endpoints
# ===================================================================

@router.post("/start-bbh", status_code=status.HTTP_201_CREATED, summary="Initialize a new meeting session")
async def start_bbh(
    session: Session = Depends(get_db_session),
    current_user: User = Depends(get_or_create_user),
    requestId: str = Form(...),
    language: str = Form("vi"),
    filename: str = Form(...),
    bbhName: str = Form(...),
    Type: str = Form(...),
    Host: str = Form(...),
    # --- ADD THIS NEW PARAMETER ---
    meetingMembers: str = Form("[]", description="A JSON string of a list of member names."),
):
    """
    Initializes a meeting job record in the database and creates a
    dedicated directory for storing incoming audio chunks.
    """
    logger.info(f"Initializing job '{requestId}' by user '{current_user.username}'.")
    if session.exec(select(MeetingJob).where(MeetingJob.request_id == requestId)).first():
        raise HTTPException(status_code=409, detail=f"Meeting job with requestId '{requestId}' already exists.")

    session_dir = Path(settings.SHARED_AUDIO_PATH) / requestId
    os.makedirs(session_dir, exist_ok=True)

    # --- ADD LOGIC TO PARSE THE JSON STRING ---
    try:
        members_list = json.loads(meetingMembers)
        if not isinstance(members_list, list):
            raise ValueError("meetingMembers must be a list.")
    except (json.JSONDecodeError, ValueError) as e:
        raise HTTPException(status_code=400, detail=f"Invalid format for meetingMembers: {e}")
    # --- END OF ADDITION ---

    job = MeetingJob(
        request_id=requestId,
        user_id=current_user.id,
        language=language,
        original_filename=filename,
        bbh_name=bbhName,
        meeting_type=Type,
        meeting_host=Host,
        # --- ADD THE PARSED LIST TO THE MODEL ---
        meeting_members=members_list,
        # --- END OF ADDITION ---
        status="uploading"
    )
    session.add(job)
    session.commit()
    return {"status": 201, "message": "Meeting initialized. Ready for chunk uploads."}


# ... (upload-file-chunk and diarize_meeting remain the same)
# ... (get_meeting_status and other endpoints remain the same)
# ...

# The update_meeting_info endpoint does NOT need to be changed.
# Because of its generic design, it will automatically handle updating the new 'meeting_members' field.

# ...

# ===================================================================
#   Analysis, Chat, and Download Endpoints
# ===================================================================

@router.post(
    "/{request_id}/summary",
    response_model=SummaryResponse,
    summary="Generate a meeting summary"
)
async def generate_summary(
    summary_request: SummaryRequest,
    db: Session = Depends(get_db_session),
    job: MeetingJob = Depends(get_owned_job_from_path) 
):
    # ... (code for getting transcript_source and source_text remains the same)

    try:
        # --- MODIFY THE CONTEXT DICTIONARY ---
        members_str = ", ".join(job.meeting_members) if job.meeting_members else "Không xác định"
        
        meeting_info = {
            "bbh_name": job.bbh_name,
            "meeting_type": job.meeting_type,
            "meeting_host": job.meeting_host,
            "meeting_members_str": members_str, # Add the new field
        }
        # --- END OF MODIFICATION ---

        summary_content = await ai_service.get_response(
            task=summary_type,
            user_message=source_text,
            context={"meeting_info": meeting_info}
        )
    # ... (rest of the function remains the same)```

### Step 4: Update the AI Prompts

Finally, add the new `meeting_members_str` variable to your summary prompts so the AI can use the information.

**File to Edit:** `app/services/ai_service.py`

```python
# app/services/ai_service.py

# ...

SUMMARY_BY_TOPIC_PROMPT = """Bạn là một Trợ lý AI chuyên nghiệp, nhiệm vụ của bạn là tạo ra một biên bản họp CHUẨN CHỈNH, RÕ RÀNG và ĐỊNH HƯỚNG HÀNH ĐỘNG từ một bản ghi hội thoại thô.

## Bối cảnh cuộc họp
- **Chủ đề:** {bbh_name}
- **Loại cuộc họp:** {meeting_type}
- **Chủ trì:** {meeting_host}
- **Thành viên tham gia:** {meeting_members_str}

## Yêu cầu
# ... (rest of prompt is unchanged)
"""

SUMMARY_BY_SPEAKER_PROMPT = """Bạn là một trợ lý AI, nhiệm vụ của bạn là phân tích bản ghi hội thoại và tóm tắt ý chính của TỪNG NGƯỜI NÓI.

## Bối cảnh cuộc họp
- **Chủ đề:** {bbh_name}
- **Loại cuộc họp:** {meeting_type}
- **Chủ trì:** {meeting_host}
- **Thành viên tham gia:** {meeting_members_str}

## Yêu cầu
# ... (rest of prompt is unchanged)
"""

# You can add the same line to SUMMARY_ACTION_ITEMS_PROMPT and SUMMARY_DECISION_LOG_PROMPT as well for consistency.
# ...
How to Apply and Test

Stop Your Application: Make sure all Docker containers are stopped.

Delete Old Database Data: Since you are not using migrations, you must delete the old database volume so the tables can be recreated with the new schema. If you are using a local volume for Postgres, you can stop the containers and run docker-compose down -v.

Restart the Application: Run docker-compose up --build. The SQLModel.metadata.create_all(engine) line in app/main.py will create the tables with the new meeting_members column.

Test the API: When calling the /start-bbh endpoint, you must now include the new meetingMembers field. Since it's a list, you need to pass it as a JSON-formatted string.

Example curl command:

code
Bash
download
content_copy
expand_less
curl -X POST http://localhost:8072/api/v1/meeting/start-bbh \
-F "requestId=test_with_members_01" \
-F "username=test_user" \
-F "filename=meeting.wav" \
-F "bbhName=Project Phoenix Kickoff" \
-F "Type=Project Meeting" \
-F "Host=Mr. Smith" \
-F 'meetingMembers=["Alice Johnson", "Bob Williams", "Charlie Brown"]'

Now, when you request a summary for this meeting, the prompt sent to the AI will include the list of members, providing it with valuable context.
