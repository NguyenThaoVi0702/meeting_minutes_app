Excellent. This is a fantastic and very common requirement for making a chatbot feel truly intelligent and helpful. You want to move from a simple command-based system to a conversational one that understands intent, checks state, and handles ambiguity.

This requires a more sophisticated approach than the previous design. We will essentially turn your backend into an orchestrator that uses the AI for two distinct tasks:

Stage 1: Intent Analysis: First, understand what the user wants to do (their intent) and what they are talking about (the entity).

Stage 2: Content Generation: Then, based on the intent, perform the appropriate action, which might involve another AI call to generate the actual text.

Here is the design and the step-by-step code modifications to implement this advanced conversational logic.

Part 1: The Design - A Two-Stage AI Approach

User sends a message: "sửa nội dung biên bản họp theo chủ đề cho tôi, thêm chi tiết về ngân sách."

Backend receives the message. Instead of immediately trying to answer, it first sends the user's text to the AI with a special "Intent Analysis" prompt.

AI (Stage 1) returns a structured JSON object, not a conversational reply. The JSON will look like this:

code
JSON
download
content_copy
expand_less
{
  "intent": "edit_summary",
  "entity": "topic",
  "confidence": 0.95,
  "edit_instruction": "thêm chi tiết về ngân sách"
}

Backend parses the JSON and enters its main logic block.

It sees intent is edit_summary.

It sees entity is topic.

Backend checks the application state (Database):

It queries the Summary table for the meeting. Does a summary with summary_type = 'topic' exist?

Backend follows the correct logic path:

Case A (Summary Exists): The backend now makes a second AI call (Stage 2). It uses the CHAT_SYSTEM_PROMPT (the one we designed before for updating summaries) and provides the existing 'topic' summary content and the edit_instruction as context. The AI returns the fully rewritten summary, and the backend saves it.

Case B (Summary Does Not Exist): The backend does not call the AI again. It constructs a specific, hard-coded response: "Biên bản họp theo 'chủ đề' chưa được tạo. Vui lòng nhấn nút 'Tóm tắt theo chủ đề' để tạo trước khi bạn có thể chỉnh sửa." and sends this back to the user.

Case C (Ambiguity): If the AI (Stage 1) returned entity: null because the user said "Sửa tóm tắt này," the backend would skip the database check and immediately return the clarifying question: "Bạn muốn sửa loại tóm tắt nào? (ví dụ: theo chủ đề, theo người nói, các công việc cần làm...)"

This design makes your backend the "brain" of the operation, using the AI as a powerful tool for language understanding rather than letting the AI control the entire flow.

Part 2: Step-by-Step Code Modifications
Step 1: Create a New, Powerful "Intent Analysis" Prompt

This is the most important new piece. We need to train the AI to act as a classifier.

File to Edit: app/services/ai_service.py

code
Python
download
content_copy
expand_less
# app/services/ai_service.py

# ... (other prompts)

# --- ADD THIS NEW PROMPT ---
INTENT_ANALYSIS_PROMPT = """Bạn là một mô hình AI chuyên phân tích ý định của người dùng trong một cuộc trò chuyện về biên bản họp. Phân tích câu cuối cùng của người dùng và trả về một đối tượng JSON DUY NHẤT.

Các loại 'intent' hợp lệ:
- 'edit_summary': Người dùng muốn chỉnh sửa, thay đổi, thêm, hoặc xóa nội dung của một bản tóm tắt.
- 'ask_question': Người dùng đang hỏi một câu hỏi về nội dung cuộc họp hoặc tóm tắt.
- 'general_chit_chat': Người dùng đang nói chuyện phiếm hoặc chào hỏi.

Các loại 'entity' (loại tóm tắt) hợp lệ:
- 'topic': Tóm tắt theo chủ đề chính.
- 'speaker': Tóm tắt theo người nói.
- 'action_items': Tóm tắt các công việc cần làm.
- 'decision_log': Tóm tắt các quyết định cuối cùng.
- null: Nếu không thể xác định hoặc người dùng không đề cập.

Cấu trúc JSON đầu ra BẮT BUỘC:
{
  "intent": "...",
  "entity": "...",
  "confidence": <số từ 0.0 đến 1.0>,
  "edit_instruction": "<Trích xuất chính xác chỉ thị chỉnh sửa của người dùng nếu có, nếu không thì để là null>"
}

Ví dụ:
- User: "sửa lại biên bản họp theo chủ đề cho tôi" -> {"intent": "edit_summary", "entity": "topic", "confidence": 0.9, "edit_instruction": null}
- User: "thêm phần ngân sách vào tóm tắt các quyết định" -> {"intent": "edit_summary", "entity": "decision_log", "confidence": 0.98, "edit_instruction": "thêm phần ngân sách"}
- User: "ai là người phụ trách công việc ABC?" -> {"intent": "ask_question", "entity": null, "confidence": 0.99, "edit_instruction": null}
- User: "sửa cái tóm tắt này" -> {"intent": "edit_summary", "entity": null, "confidence": 0.85, "edit_instruction": null}
- User: "cảm ơn bạn" -> {"intent": "general_chit_chat", "entity": null, "confidence": 0.9, "edit_instruction": null}

Bây giờ, hãy phân tích tin nhắn của người dùng sau đây.
"""
# --- END OF ADDITION ---

# ...

class AIService:
    # ...
    def _get_system_prompt_for_task(self, task: str) -> str:
        """Retrieves the appropriate system prompt based on the task type."""
        prompts = {
            "topic": SUMMARY_BY_TOPIC_PROMPT,
            "speaker": SUMMARY_BY_SPEAKER_PROMPT,
            "action_items": SUMMARY_ACTION_ITEMS_PROMPT,
            "decision_log": SUMMARY_DECISION_LOG_PROMPT,
            "summary_bbh_hdqt": SUMMARY_BBH_HDQT_PROMPT,
            "summary_nghi_quyet": SUMMARY_NGHI_QUYET_PROMPT,
            "chat": CHAT_SYSTEM_PROMPT,
            # --- ADD THIS NEW TASK ---
            "intent_analysis": INTENT_ANALYSIS_PROMPT,
            # --- END OF ADDITION ---
        }
        # ...
Step 2: Refactor the Chat Endpoint to Be the Orchestrator

This is the major change where we implement the two-stage logic.

File to Edit: app/api/routes/meeting.py

code
Python
download
content_copy
expand_less
# app/api/routes/meeting.py

# ... (imports)

# ADD THIS HELPER FUNCTION AT THE TOP OF THE FILE
def _parse_ai_json(json_string: str) -> Optional[Dict]:
    """Safely parses a JSON string that might be wrapped in markdown."""
    try:
        # Clean markdown fences
        cleaned_string = re.sub(r'```json\s*|\s*```', '', json_string, flags=re.DOTALL).strip()
        return json.loads(cleaned_string)
    except (json.JSONDecodeError, TypeError):
        logger.error(f"Failed to decode AI JSON response: {json_string}")
        return None

# ... (rest of the file until the chat endpoint)

@router.post(
    "/chat",
    response_model=ChatResponse,
    summary="Chat about the meeting content"
)
async def chat_with_meeting(
    chat_request: ChatRequest,
    db: Session = Depends(get_db_session)
):
    job = db.exec(select(MeetingJob).where(MeetingJob.request_id == chat_request.requestId)).first()
    if not job:
        raise HTTPException(status_code=404, detail="Meeting job not found.")

    final_response_to_user = "Xin lỗi, tôi chưa hiểu ý của bạn. Bạn có thể diễn đạt khác được không?"

    # --- STAGE 1: INTENT ANALYSIS ---
    try:
        intent_json_str = await ai_service.get_response(task="intent_analysis", user_message=chat_request.message)
        intent_data = _parse_ai_json(intent_json_str)

        if not intent_data:
            raise ValueError("AI did not return valid JSON for intent analysis.")

        intent = intent_data.get("intent")
        entity = intent_data.get("entity")
        edit_instruction = intent_data.get("edit_instruction") or chat_request.message

    except Exception as e:
        logger.error(f"Failed during Stage 1 (Intent Analysis): {e}")
        intent = 'ask_question' # Default to simple question if analysis fails

    # --- STAGE 2: BACKEND ORCHESTRATION ---

    # --- PATH 1: USER WANTS TO EDIT A SUMMARY ---
    if intent == 'edit_summary':
        if not entity:
            # AMBIGUITY: Ask the user to clarify
            final_response_to_user = "Bạn muốn sửa loại tóm tắt nào? (ví dụ: theo chủ đề, theo người nói, các công việc cần làm...)"
        else:
            # State Check: See if the summary exists
            summary_record = db.exec(
                select(Summary).where(Summary.meeting_job_id == job.id, Summary.summary_type == entity)
            ).first()

            if not summary_record:
                # Summary does not exist: Ask user to generate it first
                final_response_to_user = f"Biên bản họp theo '{entity}' chưa được tạo. Vui lòng nhấn nút tương ứng để tạo tóm tắt trước khi bạn có thể chỉnh sửa."
            else:
                # HAPPY PATH: Summary exists, so we can edit it.
                logger.info(f"Performing summary edit for type '{entity}' on job '{job.request_id}'.")
                
                # Construct the detailed prompt for the Stage 2 generation call
                edit_context = (
                    f"--- EXISTING '{entity.upper()}' SUMMARY ---\n"
                    f"{summary_record.summary_content}\n\n"
                    f"--- USER'S EDIT INSTRUCTION ---\n"
                    f"{edit_instruction}"
                )
                
                # This is the generation call, using the chat prompt with the update rules
                new_summary_content_raw = await ai_service.get_response(
                    task="chat", 
                    user_message=edit_context
                )
                
                # Parse the response to get the clean summary content
                update_pattern = r'\[UPDATE:(\w+)\]\s*(.*)'
                match = re.match(update_pattern, new_summary_content_raw, re.DOTALL)
                
                if match:
                    new_summary_content = match.group(2).strip()
                    summary_record.summary_content = new_summary_content
                    db.add(summary_record)
                    final_response_to_user = new_summary_content
                else:
                    # If the AI fails to follow the format, return its raw response
                    final_response_to_user = new_summary_content_raw

    # --- PATH 2: USER IS ASKING A GENERAL QUESTION ---
    elif intent == 'ask_question':
        logger.info(f"Answering a general question for job '{job.request_id}'.")
        # This is the original logic from your previous chat function
        transcript_entry = db.exec(select(Transcription).where(Transcription.meeting_job_id == job.id, Transcription.language == job.language)).first()
        transcript_text = "\n".join([seg['text'] for seg in transcript_entry.transcript_data]) if transcript_entry else ""
        
        summaries = db.exec(select(Summary).where(Summary.meeting_job_id == job.id)).all()
        summary_texts = [f"--- SUMMARY ({s.summary_type.upper()}) ---\n{s.summary_content}" for s in summaries]

        chat_history_db = db.exec(select(ChatHistory).where(ChatHistory.meeting_job_id == job.id).order_by(ChatHistory.created_at.desc()).limit(settings.LIMIT_TURN * 2)).all()
        chat_history_formatted = [{"role": entry.role, "content": entry.message} for entry in reversed(chat_history_db)]
        
        full_context_for_llm = (f"--- MEETING TRANSCRIPT ---\n{transcript_text}\n\n" + "\n\n".join(summary_texts))
        
        final_response_to_user = await ai_service.get_response(
            task="chat",
            user_message=f"**User Question:**\n{chat_request.message}\n\n**Meeting Context:**\n{full_context_for_llm}",
            context={"history": chat_history_formatted}
        )

    # --- PATH 3: GENERAL CHIT-CHAT (OR FALLBACK) ---
    else:
        final_response_to_user = "Cảm ơn bạn. Tôi có thể giúp gì khác cho cuộc họp này không?"

    # --- SAVE CONVERSATION TO HISTORY AND COMMIT ALL CHANGES ---
    db.add(ChatHistory(meeting_job_id=job.id, role="user", message=chat_request.message))
    db.add(ChatHistory(meeting_job_id=job.id, role="assistant", message=final_response_to_user))
    db.commit()

    return ChatResponse(response=final_response_to_user)

This new implementation provides a much more robust and intelligent conversational experience, fully meeting your requirements for intent detection, state checking, and ambiguity resolution.
