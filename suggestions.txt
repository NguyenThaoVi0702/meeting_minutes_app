You are absolutely right to focus on this. The presentation quality of the final document is a critical feature, and your coworker's code is indeed very clever in how it achieves a professional look.

Let's break down exactly how they did it and then modify your code to incorporate the same high-quality formatting.

Part 1: How Your Coworker's Code Achieves Good Formatting

Your coworker's code uses a smart, two-pronged approach. The key insight is that they are not just blindly converting Markdown to DOCX. They are using the powerful python-docx library to build the Word document piece by piece, interpreting the Markdown syntax themselves.

Here’s the breakdown of their md_to_docx function, which is the secret sauce:

Directly Creates a Word Document: The code starts with doc = Document(). This creates a blank Word document object in memory.

Parses Line by Line: It reads the Markdown content line by line.

Applies Native Word Styles: This is the most important step. Instead of just making text bold or large, it maps Markdown syntax to built-in Word styles:

Headings (#, ##): When it sees a line starting with #, it calls doc.add_heading(text, level=level). This doesn't just change the font size; it applies Word's "Heading 1", "Heading 2", etc., styles, which come with proper spacing and formatting defined in the document template.

Bullet Points (-, *): When it sees a bullet point, it calls doc.add_paragraph(style='List Bullet'). This applies Word's native bullet list style, ensuring correct indentation and alignment.

Numbered Lists (1.): Similarly, it uses style='List Number' for ordered lists.

Handles Inline Formatting (Bold/Italic): The helper function parse_inline_markdown is very smart. It splits a line of text into segments. For text wrapped in **...**, it creates a separate "run" (paragraph.add_run(...)) and sets its .bold property to True. This is how it can mix bold and regular text within the same paragraph.

In short, your coworker's code acts as a custom interpreter that translates simple Markdown into a structured, style-based Word document. This gives them far more control over the final appearance than a generic converter might.

Important Note: Looking at their create_meeting_minutes_doc_buffer function, they wisely use pypandoc as the primary method (because it's very powerful and supports more complex Markdown) and only use their custom md_to_docx parser as a fallback if Pandoc fails. We will adopt this robust strategy.

Part 2: How to Modify Your Code to Do Exactly That

We will integrate your coworker's logic directly into your document_generator.py service. This will ensure that all your standard summaries (topic, speaker, etc.) are beautifully formatted.

File to Edit: app/services/document_generator.py

This will be the only file you need to change. We will add the helper functions and then update the main function to use them.

code
Python
download
content_copy
expand_less
# app/services/document_generator.py

import json
import logging
from io import BytesIO
from pathlib import Path
from docxtpl import DocxTemplate
from app.utils import create_subdoc_from_structured_data
import pypandoc
import os
from docx import Document # <-- ADD THIS IMPORT

logger = logging.getLogger(__name__)
TEMPLATES_DIR = Path(__file__).resolve().parent.parent.parent / "templates"

# --- THIS IS THE ORIGINAL FUNCTION FOR TEMPLATES (UNCHANGED) ---
def generate_templated_document(template_type: str, llm_json_output: str) -> BytesIO:
    # ... (this function is unchanged)
    template_map = {
        "bbh_hdqt": "bbh_hdqt_template.docx",
        "nghi_quyet": "nghi_quyet_template.docx",
    }
    template_filename = template_map.get(template_type)
    if not template_filename:
        raise ValueError(f"Invalid template type: {template_type}")

    template_path = TEMPLATES_DIR / template_filename
    if not template_path.exists():
        raise FileNotFoundError(f"Template file not found at: {template_path}")

    try:
        doc = DocxTemplate(template_path)
        context_data = json.loads(llm_json_output)
        
        render_context = {}
        for key, value in context_data.items():
            if isinstance(value, list):
                render_context[key] = create_subdoc_from_structured_data(doc, value)
            else:
                render_context[key] = value
        
        doc.render(render_context)
        
        buffer = BytesIO()
        doc.save(buffer)
        buffer.seek(0)
        return buffer

    except json.JSONDecodeError:
        logger.error(f"Failed to decode LLM JSON: {llm_json_output}")
        raise ValueError("AI service returned invalid JSON.")
    except Exception as e:
        logger.error(f"Failed to generate document for template '{template_type}': {e}", exc_info=True)
        raise RuntimeError("An unexpected error occurred during document generation.")


# --- ADD YOUR COWORKER'S HELPER FUNCTIONS EXACTLY AS THEY WERE ---

def _parse_inline_markdown(text, paragraph):
    """
    Parses a string for **bold** and *italic* markdown and adds
    formatted runs to a python-docx paragraph object.
    """
    import re
    parts = re.split(r'(\*\*.*?\*\*|\*.*?\*)', text)
    for part in parts:
        if part.startswith('**') and part.endswith('**'):
            run = paragraph.add_run(part[2:-2])
            run.bold = True
        elif part.startswith('*') and part.endswith('*'):
            run = paragraph.add_run(part[1:-1])
            run.italic = True
        elif part:
            paragraph.add_run(part)

def _md_to_docx_custom_parser(markdown_content: str) -> BytesIO:
    """
    A custom, line-by-line parser that converts simple Markdown to a 
    well-formatted DOCX using python-docx styles. This is the fallback method.
    """
    doc = Document()
    lines = markdown_content.strip().split('\n')

    for line in lines:
        line = line.rstrip()
        if not line.strip():
            continue

        # Headings
        if line.startswith('#'):
            level = len(line) - len(line.lstrip('#'))
            text = line.lstrip('#').strip()
            doc.add_heading(text, level=min(level, 4))
        # Unordered list
        elif line.strip().startswith(('-', '*')):
            text = line.strip().lstrip('-* ').strip()
            p = doc.add_paragraph(style='List Bullet')
            _parse_inline_markdown(text, p)
        # Ordered list
        elif line.strip() and line.strip()[0].isdigit() and '.' in line:
            text = line.split('.', 1)[1].strip()
            p = doc.add_paragraph(style='List Number')
            _parse_inline_markdown(text, p)
        # Normal paragraph
        else:
            p = doc.add_paragraph()
            _parse_inline_markdown(line, p)

    buffer = BytesIO()
    doc.save(buffer)
    buffer.seek(0)
    return buffer


# --- REPLACE the old `generate_docx_from_markdown` WITH THIS new version ---
def generate_docx_from_markdown(markdown_content: str) -> BytesIO:
    """
    Converts a markdown string to a DOCX file in memory.
    It first tries using the powerful Pandoc converter. If that fails,
    it falls back to a custom parser for guaranteed basic formatting.
    """
    temp_dir = Path("./temp_docs")
    os.makedirs(temp_dir, exist_ok=True)
    
    markdown_file_path = temp_dir / 'temp.md'

    try:
        with open(markdown_file_path, 'w', encoding='utf-8') as f:
            f.write(markdown_content)

        logger.info(f"Attempting markdown to DOCX conversion using Pandoc...")
        # Use a BytesIO object directly with Pandoc if possible to avoid temp files
        output_buffer = BytesIO()
        pypandoc.convert_file(
            str(markdown_file_path),
            to='docx',
            outputfile=None, # Signal to return bytes
            extra_args=['--standalone']
        )
        # pypandoc.convert_text doesn't handle some complex cases as well as file
        output_bytes = pypandoc.convert_file(str(markdown_file_path), 'docx')
        output_buffer.write(output_bytes)
        output_buffer.seek(0)
        
        logger.info("Pandoc conversion successful!")
        return output_buffer

    except Exception as e:
        logger.warning(f"Pandoc conversion failed: {e}. Falling back to custom parser.")
        # FALLBACK to the custom, style-based parser
        return _md_to_docx_custom_parser(markdown_content)
    finally:
        # Clean up the temporary markdown file
        if os.path.exists(markdown_file_path):
            os.remove(markdown_file_path)
Summary of Changes and Why They Work

Copied Helper Functions: We've added _parse_inline_markdown and created _md_to_docx_custom_parser based on your coworker's logic. These functions are now available within your service. I've prefixed them with an underscore (_) to indicate they are internal helper functions.

Upgraded generate_docx_from_markdown: The main function that your download endpoint calls is now much more robust.

Pandoc First: It will always try to use pypandoc first. Pandoc is an extremely powerful tool that can handle complex tables, nested lists, and other rich Markdown features that the custom parser cannot. This gives you the best possible conversion for complex content.

Custom Parser as a Fallback: If Pandoc fails for any reason (e.g., it's not installed correctly in the environment, or there's a weird formatting issue it can't handle), the except block will catch the error and run the custom _md_to_docx_custom_parser.

Guaranteed Quality: This fallback guarantees that for all your standard summaries—which are composed of headings, paragraphs, and lists—you will always get the well-formatted DOCX output with proper Word styles, just like your coworker's code produced.

No Other Changes Needed: Your download_summary_document endpoint in meeting.py is already perfect. It correctly calls this service function, so you don't need to touch it.

By making these changes to app/services/document_generator.py, you have successfully integrated the high-quality formatting logic into your application for all standard summary types.
