@router.post(
    "/",
    status_code=status.HTTP_202_ACCEPTED,
    response_model=GenericSuccessResponse,
    summary="Enroll a new speaker profile"
)
async def enroll_new_speaker(
    metadata_json: str = Form(..., alias="metadata"),
    files: List[UploadFile] = File(...)
):
    """
    Accepts a new speaker enrollment request, saves the audio samples,
    and queues the heavy processing (embedding generation) to a background worker.
    """
    try:
        # Step 1: Validate incoming metadata
        try:
            metadata = SpeakerMetadataUpdate.model_validate_json(metadata_json)
        except ValidationError as e:
            raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=f"Invalid metadata JSON: {e}")

        user_ad = metadata.user_ad.lower().strip()
        if not user_ad:
            raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail="user_ad is a required field in metadata.")

        # Step 2: Check for duplicate speaker in the vector database
        points, _ = qdrant_client.scroll(
            collection_name=settings.QDRANT_COLLECTION_NAME,
            scroll_filter=models.Filter(must=[models.FieldCondition(key="user_ad", match=models.MatchValue(value=user_ad))]),
            limit=1
        )
        if points:
            # If a speaker exists, raise a specific 409 Conflict error
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=f"Speaker with user_ad '{user_ad}' already exists.")

        # Step 3: Save uploaded files
        enrollment_dir = FilePath(settings.ENROLLMENT_SAMPLES_PATH) / user_ad
        os.makedirs(enrollment_dir, exist_ok=True)
        
        saved_paths = []
        for file in files:
            if not file.filename: continue
            file_path = enrollment_dir / f"{uuid.uuid4()}_{file.filename}"
            with open(file_path, "wb") as buffer:
                shutil.copyfileobj(file.file, buffer)
            saved_paths.append(str(file_path))

        if not saved_paths:
            raise HTTPException(status_code=400, detail="No valid audio files were provided for enrollment.")

        # Step 4: Dispatch the background task
        celery_app.send_task("enroll_speaker_task", args=[user_ad, saved_paths, metadata.model_dump()])

        return GenericSuccessResponse(message=f"Enrollment for speaker '{user_ad}' has been accepted for processing.")

    except HTTPException:
        # This will catch any HTTPException raised above (like 409, 422, 400)
        # and re-raise it, preserving the original status code and detail.
        raise
    except Exception as e:
        # This is a catch-all for unexpected errors (e.g., cannot connect to Qdrant)
        # and will correctly return a 503 Service Unavailable.
        logger.error(f"Failed to enroll speaker '{metadata.user_ad if 'metadata' in locals() else 'unknown'}': {e}", exc_info=True)
        raise HTTPException(status_code=503, detail=f"A service error occurred while trying to enroll the speaker: {e}")
