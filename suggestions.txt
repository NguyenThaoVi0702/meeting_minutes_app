Excellent. These are great refinements that will significantly improve the user experience and simplify the application's focus. You want to make the system more proactive and streamlined.

Here is a complete guide on how to implement both of these changes.

Part 1: Auto-Generate Summary on Download (If Not Found)

This is a fantastic UX improvement. Instead of showing an error, the system will just do the work the user expects. The best way to achieve this without duplicating code is to refactor your summary generation logic into a reusable internal helper function.

File to Edit: app/api/routes/meeting.py

We will create a new helper function _generate_and_save_summary and then use it in both the main summary endpoint and the download endpoint.

code
Python
download
content_copy
expand_less
# app/api/routes/meeting.py

# ... (all imports remain the same)

# --- 1. CREATE THIS NEW REUSABLE HELPER FUNCTION ---
# Place this function right before your `get_or_generate_summary` endpoint.

async def _generate_and_save_summary(db: Session, job: MeetingJob, summary_type: str) -> Summary:
    """
    Internal helper to generate a summary, save it to the DB, and return the new object.
    This contains the core generation logic, preventing code duplication.
    """
    logger.info(f"Generating a new '{summary_type}' summary for job '{job.request_id}'.")
    
    # Prepare transcript source text
    if summary_type == "speaker":
        if not job.diarized_transcript:
            raise HTTPException(status_code=400, detail="A 'speaker' summary requires diarization.")
        transcript_source = job.diarized_transcript.transcript_data
        source_text = "\n".join([f"{seg['speaker']}: {seg['text']}" for seg in transcript_source])
    else:
        transcription_entry = db.exec(select(Transcription).where(Transcription.meeting_job_id == job.id, Transcription.language == job.language)).first()
        if not transcription_entry or not transcription_entry.transcript_data:
            raise HTTPException(status_code=400, detail="A summary requires a completed transcript.")
        transcript_source = transcription_entry.transcript_data
        source_text = "\n".join([seg['text'] for seg in transcript_source])

    # Generate content using AI service
    try:
        meeting_info = { "bbh_name": job.bbh_name, "meeting_type": job.meeting_type, "meeting_host": job.meeting_host, }
        if summary_type in ["summary_bbh_hdqt", "summary_nghi_quyet"]:
            local_tz = ZoneInfo("Asia/Ho_Chi_Minh")
            start_time_local = job.upload_started_at.replace(tzinfo=timezone.utc).astimezone(local_tz) if job.upload_started_at else None
            end_time_local = job.upload_finished_at.replace(tzinfo=timezone.utc).astimezone(local_tz) if job.upload_finished_at else None
            context_header = (
                f"**THÔNG TIN BỐI CẢNH CUỘC HỌP:**\n"
                f"- Ngày họp: {start_time_local.strftime('%d/%m/%Y') if start_time_local else 'N/A'}\n"
                f"- Giờ bắt đầu: {start_time_local.strftime('%H:%M') if start_time_local else 'N/A'}\n"
                f"- Giờ kết thúc: {end_time_local.strftime('%H:%M') if end_time_local else 'N/A'}\n\n"
                f"**NỘI DUNG BIÊN BẢN (TRANSCRIPT):**\n"
            )
            source_text = context_header + source_text

        summary_content = await ai_service.get_response(
            task=summary_type,
            user_message=source_text,
            context={"meeting_info": meeting_info}
        )
    except Exception as e:
        raise HTTPException(status_code=502, detail=f"Failed to get response from AI service: {e}")

    # Save the newly generated summary to DB
    new_summary = Summary(
        meeting_job_id=job.id,
        summary_type=summary_type,
        summary_content=summary_content
    )
    db.add(new_summary)
    db.commit()
    db.refresh(new_summary)
    logger.info(f"Successfully generated and saved new '{summary_type}' summary.")
    return new_summary


# --- 2. MODIFY THE /summary ENDPOINT TO USE THE HELPER ---

@router.post(
    "/{request_id}/summary",
    response_model=SummaryResponse,
    summary="Get, or generate and save, a meeting summary"
)
async def get_or_generate_summary(
    summary_request: SummaryRequest,
    db: Session = Depends(get_db_session),
    job: MeetingJob = Depends(get_owned_job_from_path)
):
    # ... (function description remains the same)
    db.add(job)
    summary_type = summary_request.summary_type
    
    existing_summary = db.exec(
        select(Summary).where(
            Summary.meeting_job_id == job.id,
            Summary.summary_type == summary_type
        )
    ).first()

    if existing_summary:
        summary_to_return = existing_summary
    else:
        # If not found, call our new helper to generate and save it
        summary_to_return = await _generate_and_save_summary(db, job, summary_type)

    return SummaryResponse(
        request_id=job.request_id,
        summary_type=summary_to_return.summary_type,
        summary_content=summary_to_return.summary_content
    )


# --- 3. MODIFY THE /download/document ENDPOINT TO USE THE HELPER ---

@router.get("/{request_id}/download/document", summary="Download any summary as a DOCX document")
async def download_summary_document(
    job: MeetingJob = Depends(get_owned_job_from_path),
    summary_type: str = Query(..., description="The type of summary to download."),
    db: Session = Depends(get_db_session)
):
    # ... (function description remains the same)
    summary = db.exec(
        select(Summary).where(
            Summary.meeting_job_id == job.id,
            Summary.summary_type == summary_type
        )
    ).first()

    # --- THIS IS THE KEY CHANGE ---
    if not summary:
        # If summary is not found, generate and save it on the fly!
        logger.warning(f"Summary '{summary_type}' not found for download. Generating now...")
        summary = await _generate_and_save_summary(db, job, summary_type)
    # --- END OF CHANGE ---

    # The rest of the download logic remains exactly the same.
    try:
        if summary_type in ["summary_bbh_hdqt", "summary_nghi_quyet"]:
            document_buffer = generate_templated_document(summary_type.replace("summary_", ""), summary.summary_content)
        else:
            document_buffer = generate_docx_from_markdown(summary.summary_content)
    except Exception as e:
        logger.error(f"Error during document generation for type '{summary_type}': {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Failed to generate the document: {e}")

    filename = f"{summary_type}_{job.bbh_name.replace(' ', '_')}.docx"
    headers = {"Content-Disposition": f"attachment; filename*=UTF-8''{filename}"}
    
    return StreamingResponse(
        document_buffer,
        media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        headers=headers
    )

Now, your application will seamlessly handle requests for summaries that haven't been created yet, providing a much smoother user flow.

Part 2: Disabling action_items and decision_log

This is a straightforward process of removing references to these two summary types from your AI service prompts.

File to Edit: app/services/ai_service.py

code
Python
download
content_copy
expand_less
# app/services/ai_service.py

# ... (imports)

def _clean_ai_response(text: str) -> str:
    # ... (this function is unchanged)

# --- 1. DELETE THE UNUSED PROMPT STRINGS ---
# You can completely remove the SUMMARY_ACTION_ITEMS_PROMPT and 
# SUMMARY_DECISION_LOG_PROMPT variable definitions to keep the code clean.

# (For brevity, I'll just show the parts to modify)

# --- 2. UPDATE THE INTENT ANALYSIS PROMPT ---
INTENT_ANALYSIS_PROMPT = """Bạn là một mô hình AI chuyên phân tích ý định của người dùng...
...
Các loại 'entity' (loại tóm tắt) hợp lệ:
- 'topic': Tóm tắt theo chủ đề chính.
- 'speaker': Tóm tắt theo người nói.
- 'summary_bbh_hdqt': Biên bản họp dạng chi tiết (JSON).
- 'summary_nghi_quyet': Nghị quyết cuộc họp (JSON).
- null: Nếu không thể xác định hoặc người dùng không đề cập.
...
""" # The rest of this prompt is unchanged

# ... (other prompts like SUMMARY_BY_TOPIC_PROMPT are unchanged)

class AIService:
    # ... (init is unchanged)

    def _get_system_prompt_for_task(self, task: str) -> str:
        """Retrieves the appropriate system prompt based on the task type."""
        # --- 3. REMOVE THE ENTRIES FROM THE DICTIONARY ---
        prompts = {
            "topic": SUMMARY_BY_TOPIC_PROMPT,
            "speaker": SUMMARY_BY_SPEAKER_PROMPT,
            # "action_items": SUMMARY_ACTION_ITEMS_PROMPT, # <-- DELETE THIS LINE
            # "decision_log": SUMMARY_DECISION_LOG_PROMPT, # <-- DELETE THIS LINE
            "summary_bbh_hdqt": SUMMARY_BBH_HDQT_PROMPT,
            "summary_nghi_quyet": SUMMARY_NGHI_QUYET_PROMPT,
            "chat": CHAT_SYSTEM_PROMPT,
            "intent_analysis": INTENT_ANALYSIS_PROMPT,
        }
        prompt = prompts.get(task)
        if not prompt:
            logger.error(f"Unknown AI task requested: {task}")
            raise ValueError(f"Unknown AI task: {task}")
        return prompt

    # ... (get_response is unchanged)

ai_service = AIService()
Final Recommendation: Update Your Test Script

To prevent your tests from failing, you should also update the list of summaries being tested in your test_code.py file.

File to Edit: test_code.py

code
Python
download
content_copy
expand_less
# test_code.py
# ...

    # --- NEW: Loop to test ALL summary types ---
    # Update this list to reflect the new, focused set of summaries
    summary_types_to_test = ["topic", "speaker"] # "action_items" and "decision_log" are removed
    print(f"\nTesting all {len(summary_types_to_test)} summary endpoints...")

# ...

By completing these steps, you have successfully implemented both of your requests. The application is now more user-friendly, as it generates content on demand, and more focused, offering a curated set of high-value summary options.
