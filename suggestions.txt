Of course. Thank you for providing the detailed test results and logs. This is excellent diagnostic information.

You are facing three distinct and separate issues. Let's solve them one by one, from the most critical to the simplest.

Issue #1: UnicodeEncodeError in Download Headers (Critical)

This is the error causing the 500 Internal Server Error when you try to download the topic and speaker summaries.

The Problem:
Your log file shows the exact error:

code
Code
download
content_copy
expand_less
UnicodeEncodeError: 'latin-1' codec can't encode character '\u1ed9' in position 39: ordinal not in range(256)

This happens because your meeting's bbh_name (e.g., "Cuộc Họp...") contains Vietnamese characters. The default HTTP header encoding is latin-1 (a very limited character set), which cannot handle these characters. When FastAPI/Starlette tries to create the Content-Disposition header for the filename, it fails.

The Solution:
We need to properly URL-encode the filename so it's safe for use in an HTTP header.

File to Edit: app/api/routes/meeting.py

code
Python
download
content_copy
expand_less
# app/api/routes/meeting.py

# --- ADD `quote` to your imports from urllib.parse ---
from urllib.parse import quote
# (It might already be in another file, but ensure it's here)

# ... (other code)

@router.get("/{request_id}/download/document", summary="Download any summary as a DOCX document")
async def download_summary_document(
    # ... (function signature is unchanged)
):
    # ... (all the logic to get or generate the summary is unchanged)
    
    # --- THIS IS THE FIX ---
    safe_filename_part = job.bbh_name.replace(' ', '_').replace('/', '_')
    encoded_filename = quote(f"{summary_type}_{safe_filename_part}.docx")
    
    # Use the 'filename*' parameter which is the modern standard for non-ASCII filenames
    headers = {"Content-Disposition": f"attachment; filename*=UTF-8''{encoded_filename}"}
    # --- END OF FIX ---
    
    return StreamingResponse(
        document_buffer,
        media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        headers=headers
    )

This change ensures that any special characters in your meeting name are safely encoded, which will resolve the UnicodeEncodeError and allow the document downloads to succeed.

Issue #2: Pandoc Not Found (High Priority)

Even with the download error fixed, your logs clearly show the next problem.

The Problem:

code
Code
download
content_copy
expand_less
WARNING - app.services.document_generator - Pandoc conversion failed: No pandoc was found: either install pandoc and add it to your PATH...

This error is very specific. pypandoc is just a Python wrapper or "remote control" for the main Pandoc application. Your pip show command confirms that the wrapper is installed, but the underlying Pandoc program itself is missing from your Docker container's operating system. You cannot install it with pip.

The Solution:
Since your company's network restricts apt-get, we cannot install it the easy way. The most robust alternative is to download the Pandoc binary directly and copy it into your Docker image.

Download Pandoc: Go to the official Pandoc releases page. Find a recent release and download the .deb file for Debian/Ubuntu. For example, pandoc-3.1.9-1-amd64.deb. Save this file in the root directory of your project (the same place as your Dockerfile).

Modify Your Dockerfile: Add commands to copy and install this local .deb file.

File to Edit: Dockerfile

code
Dockerfile
download
content_copy
expand_less
FROM dso-nexus.vietinbank.vn/ai_docker/diarization_transcription_service:v1

ENV DEBIAN_FRONTEND=noninteractive
ENV TZ=Asia/Ho_Chi_Minh
ENV PYTHONUNBUFFERED=1

WORKDIR /code

# --- ADD THIS SECTION TO INSTALL PANDOC FROM THE LOCAL FILE ---
# 1. Copy the downloaded .deb file into the image
COPY pandoc-3.1.9-1-amd64.deb /tmp/pandoc.deb

# 2. Install the .deb package using dpkg
RUN apt-get update && apt-get install -y /tmp/pandoc.deb && rm /tmp/pandoc.deb
# --- END OF ADDITION ---

# Your existing pip and code copying commands remain the same
ENV PYTHONPATH=/app

RUN pip config set global.index-url ***
RUN pip config set global.trusted-host ***

RUN pip install --no-cache-dir --upgrade pip

COPY requirements.txt .

RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir --timeout 60 -r requirements.txt

COPY ./app /code/app

EXPOSE 8072

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8072"]

(Note: Replace pandoc-3.1.9-1-amd64.deb with the exact filename you downloaded.)

After rebuilding your image with docker-compose build --no-cache, the Pandoc program will be correctly installed, and your high-quality document conversion will work as intended.

Issue #3: Missing Keys in AI Prompt (Medium Priority)

This is the cause of the 502 Bad Gateway errors for summary_bbh_hdqt and summary_nghi_quyet.

The Problem:
The log shows a KeyError happening inside the ai_service.py file:

code
Code
download
content_copy
expand_less
File "/code/app/services/ai_service.py", line 87, in get_response
  system_prompt = system_prompt.format(**context["meeting_info"])
KeyError: 'start_time'

This means your SUMMARY_BBH_HDQT_PROMPT contains placeholders like {start_time} that you are not providing in the meeting_info dictionary. Your code currently only adds bbh_name, meeting_type, and meeting_host.

The Solution:
We need to populate the meeting_info dictionary with all the required keys when generating these specific summaries.

File to Edit: app/api/routes/meeting.py

code
Python
download
content_copy
expand_less
# app/api/routes/meeting.py

# ... (in the _generate_and_save_summary helper function)

async def _generate_and_save_summary(db: Session, job: MeetingJob, summary_type: str) -> Summary:
    # ... (code to get transcript source text is unchanged)

    # Generate content using AI service
    try:
        # --- THIS IS THE FIX ---
        meeting_info = {
            "bbh_name": job.bbh_name,
            "meeting_type": job.meeting_type,
            "meeting_host": job.meeting_host,
            # Add default/fallback values for all keys used in the prompts
            "start_time": "N/A",
            "end_time": "N/A",
            "ngay": "N/A",
            "thang": "N/A",
            "nam": "N/A",
            "meeting_members_str": ", ".join(job.meeting_members) if job.meeting_members else "Không xác định"
        }
        
        if summary_type in ["summary_bbh_hdqt", "summary_nghi_quyet"]:
            local_tz = ZoneInfo("Asia/Ho_Chi_Minh")
            start_time_local = job.upload_started_at.replace(tzinfo=timezone.utc).astimezone(local_tz) if job.upload_started_at else None
            end_time_local = job.upload_finished_at.replace(tzinfo=timezone.utc).astimezone(local_tz) if job.upload_finished_at else None
            
            # Overwrite defaults with real values if they exist
            if start_time_local:
                meeting_info["start_time"] = start_time_local.strftime('%H:%M')
                meeting_info["ngay"] = start_time_local.strftime('%d')
                meeting_info["thang"] = start_time_local.strftime('%m')
                meeting_info["nam"] = start_time_local.strftime('%Y') # Use 4-digit year for clarity
            
            if end_time_local:
                meeting_info["end_time"] = end_time_local.strftime('%H:%M')

            # The source_text preparation remains the same
            context_header = (
                f"**THÔNG TIN BỐI CẢNH CUỘC HỌP:**\n"
                f"- Ngày họp: {start_time_local.strftime('%d/%m/%Y') if start_time_local else 'N/A'}\n"
                f"- Giờ bắt đầu: {meeting_info['start_time']}\n"
                f"- Giờ kết thúc: {meeting_info['end_time']}\n\n"
                f"**NỘI DUNG BIÊN BẢN (TRANSCRIPT):**\n"
            )
            source_text = context_header + source_text
        # --- END OF FIX ---
        
        summary_content = await ai_service.get_response(
            task=summary_type,
            user_message=source_text,
            context={"meeting_info": meeting_info} # This now contains all required keys
        )
    # ... (rest of function is unchanged)

By pre-populating the meeting_info dictionary with default values and then overwriting them, you guarantee that the .format() call will never fail, resolving the 502 errors.
